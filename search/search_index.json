{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Star Log-extended eMulator","text":"<p>Welcome to our documentation webpage for the Star Log-extended eMulator (SLM) package.</p> <p></p> <p>Welcome to the Star Log-extended eMulation (SLM) package! Here we provide open source code for implementing the emulators we developed for the Tolman-Oppenheimer-Volkoff (TOV) equations. These include:</p> <ul> <li>The original SLM emulator that is capable of handling logarithmically nonlinear ordinary differential equations, e.g., the TOV equations including tidal deformability.</li> <li>A parametric extension of the original emulator, parametric SLM (pSLM) that is able to map between parameters of the equation of state (EOS) to the neutron star properties of mass, radius, and tidal deformability.</li> </ul> <p>These emulators exhibit a computational speed-up of \\(\\approx 10^{4}\\) times that of the high fidelity (HF) TOV solver employing standard Runge-Kutta (RK) methods, enabling their use in computationally intensive Bayesian frameworks used by multi-messenger astrophysical collaborations, e.g., the LIGO-Virgo-KAGRA collaboration. These emulators can also be further developed for use outside of nuclear astrophysics---feel free to try extending them or using them on your own physics or mathematics problem of interest!</p>"},{"location":"#installation-instructions","title":"Installation instructions","text":"<p>To install the most recent stable version of this package, run the command <pre><code>pip install SLM\n</code></pre></p> <p>To install this package in developer mode, run the following: <pre><code>git clone https://github.com/asemposki/SLM.git\ncd SLM\npip install -e .\n</code></pre></p>"},{"location":"#testing","title":"Testing","text":"<p>To use the testing suite in this repository, go inside the <code>tests</code> folder and simply run the command <pre><code>python3 -m pytest\n</code></pre> to run all of the tests at once. To run an individual test, use the command <pre><code>python3 pytest &lt;testing file name&gt;\n</code></pre> inside of the <code>tests</code> folder.</p>"},{"location":"#citing-this-package","title":"Citing this package","text":"<p>Our article based on this work was recently accepted in Phys. Rev. Research, but until it is published, keep using this link to cite our work:</p> <pre><code>@article{Lalit:2024vmu,\n    author = \"Lalit, Sudhanva and Semposki, Alexandra C. and Maldonado, Joshua M.\",\n    title = \"{Star Log-extended eMulation: a method for efficient computation of the Tolman-Oppenheimer-Volkoff equations}\",\n    eprint = \"2411.10556\",\n    archivePrefix = \"arXiv\",\n    primaryClass = \"astro-ph.HE\",\n    month = \"11\",\n    year = \"2024\"\n}\n</code></pre>"},{"location":"#author-contact-information","title":"Author contact information","text":"<ul> <li>Sudhanva S. Lalit (FRIB/MSU): lalit@frib.msu.edu</li> <li>Alexandra C. Semposki (Ohio U): as727414@ohio.edu</li> <li>Joshua M. Maldonado (Ohio U): jm998521@ohio.edu</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>This section provides a detailed reference for the code in the <code>Star Log-extended eMulator</code> package.</p>"},{"location":"api/#slmemulator.SLM","title":"<code>SLM</code>","text":""},{"location":"api/#slmemulator.SLM.augment_data_multiple_columns","title":"<code>augment_data_multiple_columns(X)</code>","text":"<p>Augment the data matrix X with nonlinear terms for multiple variables.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>The data matrix where each row is a variable, and each column  is a snapshot in time.</p> required <p>Returns:</p> Name Type Description <code>augmented_X</code> <code>ndarray</code> <p>The augmented data matrix with nonlinear terms.</p> Source code in <code>src/slmemulator/SLM.py</code> <pre><code>def augment_data_multiple_columns(X):\n    r\"\"\"\n    Augment the data matrix X with nonlinear terms for multiple variables.\n\n    Parameters:\n        X (np.ndarray): The data matrix where each row is a variable, and each column \n            is a snapshot in time.\n\n    Returns:\n        augmented_X (np.ndarray): The augmented data matrix with nonlinear terms.\n    \"\"\"\n    n_variables, n_snapshots = X.shape\n\n    # Calculate the number of augmented terms\n    num_augmented_terms = sum(\n        1 for _ in combinations_with_replacement(range(n_variables), 2)\n    )\n\n    # Pre-allocate the augmented matrix\n    augmented_X = np.empty(\n        (n_variables + num_augmented_terms, n_snapshots), dtype=X.dtype\n    )\n    augmented_X[:n_variables, :] = X\n\n    # Add quadratic terms and cross-products\n    row_idx = n_variables\n    for i, j in combinations_with_replacement(range(n_variables), 2):\n        augmented_X[row_idx, :] = X[i, :] * X[j, :]\n        row_idx += 1\n\n    return augmented_X\n</code></pre>"},{"location":"api/#slmemulator.SLM.SLM","title":"<code>SLM(X, dt, error_threshold=0.0001, max_r=None)</code>","text":"<p>Dynamic Mode decomposition for the augmented Data. Automatically determines the number of modes (r) based on an error threshold.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>The data matrix where each row is a variable, and each column is a snapshot  in time. Expected to be log-transformed where appropriate.</p> required <code>dt</code> <code>float</code> <p>The time difference of linear DMDs.</p> required <code>error_threshold</code> <code>float</code> <p>(Optional) The maximum allowed absolute difference between the  original data and the DMD reconstruction. Defaults to 1e-4.</p> <code>0.0001</code> <code>max_r</code> <code>int</code> <p>(Optional) The maximum number of modes to consider. If None, it will go up to the maximum possible rank (min(X.shape)).</p> <code>None</code> Source code in <code>src/slmemulator/SLM.py</code> <pre><code>def SLM(X, dt, error_threshold=1e-4, max_r=None):\n    r\"\"\"\n    Dynamic Mode decomposition for the augmented Data.\n    Automatically determines the number of modes (r) based on an error threshold.\n\n    Parameters:\n        X (np.ndarray): The data matrix where each row is a variable, and each column is a snapshot \n            in time. Expected to be log-transformed where appropriate.\n\n        dt (np.float): The time difference of linear DMDs.\n\n        error_threshold (float): (Optional) The maximum allowed absolute difference between the \n            original data and the DMD reconstruction. Defaults to 1e-4.\n\n        max_r (int): (Optional) The maximum number of modes to consider. If None, it will go up to\n            the maximum possible rank (min(X.shape)).\n    \"\"\"\n    n = X.shape[0]  # Original number of variables before augmentation\n\n    X_augmented = augment_data_multiple_columns(X)\n    X1 = X_augmented[:, :-1]  # All columns except the last\n    X2 = X_augmented[:, 1:]  # All columns except the first\n\n    # Compute SVD of X1 once\n    U_full, S_full, Vt_full = np.linalg.svd(X1, full_matrices=False)\n\n    # Determine the maximum possible rank\n    max_possible_r = min(X1.shape)\n    if max_r is None:\n        max_r_to_check = max_possible_r\n    else:\n        max_r_to_check = min(max_r, max_possible_r)\n\n    # Initialize r and best_error\n    r_optimal = 1\n    min_error = float(\"inf\")\n    best_Xdmd = None\n    best_Phi = None\n    best_omega = None\n    best_lambda_vals = None\n    best_b = None\n\n    # Iterate through possible ranks to find the optimal 'r'\n    for r_current in range(1, max_r_to_check + 1):\n        U_r = U_full[:, :r_current]\n        S_r_inv = np.diag(1.0 / S_full[:r_current])\n        V_r = Vt_full[:r_current, :]\n\n        # Compute Atilde\n        Atilde = U_r.T @ X2 @ V_r.T @ S_r_inv\n\n        # Compute eigenvectors and eigenvalues\n        D, W_r = np.linalg.eig(Atilde)\n\n        Phi_current = X2 @ V_r.T @ S_r_inv @ W_r  # DMD modes\n        lambda_vals_current = D  # discrete-time eigenvalues\n        omega_current = np.log(lambda_vals_current) / dt  # continuous-time eigenvalue\n\n        # Compute DMD mode amplitudes b\n        x1 = X1[:, 0]\n        b_current = np.linalg.lstsq(Phi_current, x1, rcond=None)[0]\n\n        # DMD reconstruction for the current 'r'\n        mm1 = X1.shape[1] + 1\n        t = np.arange(mm1) * dt\n\n        time_dynamics_current = b_current[:, np.newaxis] * np.exp(\n            omega_current[:, np.newaxis] * t\n        )\n        Xdmd2_current = Phi_current @ time_dynamics_current\n\n        # Truncate to original number of variables (log-transformed)\n        Xdmd_current_original_vars = Xdmd2_current[:n, :]\n\n        # Calculate error (max absolute difference)\n        # Using original X (log-transformed) for comparison\n        current_error = np.max(np.abs(X - Xdmd_current_original_vars))\n\n        print(f\"Testing r={r_current}: Max absolute error = {current_error:.6f}\")\n\n        if current_error &lt;= error_threshold:\n            r_optimal = r_current\n            min_error = current_error\n            # Store the results for the optimal r\n            best_Xdmd = Xdmd_current_original_vars\n            best_Phi = Phi_current[:n, :]  # Truncate Phi to original variables\n            best_omega = omega_current\n            best_lambda_vals = lambda_vals_current\n            best_b = b_current\n            break  # Found the smallest r that satisfies the threshold\n\n        # If we didn't meet the threshold, but this r gives the best error so far, keep its results\n        if current_error &lt; min_error:\n            min_error = current_error\n            r_optimal = r_current\n            best_Xdmd = Xdmd_current_original_vars\n            best_Phi = Phi_current[:n, :]\n            best_omega = omega_current\n            best_lambda_vals = lambda_vals_current\n            best_b = b_current\n\n    print(f\"Optimal 'r' determined: {r_optimal} (Max absolute error = {min_error:.6f})\")\n\n    # If no 'r' met the threshold, use the one that gave the minimum error\n    if best_Xdmd is None:  # This should not happen if max_r_to_check &gt;= 1\n        # Fallback to a default if no optimal r is found (e.g., r=1)\n        r_optimal = 1\n        U_r = U_full[:, :r_optimal]\n        S_r_inv = np.diag(1.0 / S_full[:r_optimal])\n        V_r = Vt_full[:r_optimal, :]\n        Atilde = U_r.T @ X2 @ V_r.T @ S_r_inv\n        D, W_r = np.linalg.eig(Atilde)\n        best_Phi = X2 @ V_r.T @ S_r_inv @ W_r\n        best_lambda_vals = D\n        best_omega = np.log(best_lambda_vals) / dt\n        x1 = X1[:, 0]\n        best_b = np.linalg.lstsq(best_Phi, x1, rcond=None)[0]\n        mm1 = X1.shape[1] + 1\n        t = np.arange(mm1) * dt\n        time_dynamics = best_b[:, np.newaxis] * np.exp(best_omega[:, np.newaxis] * t)\n        best_Xdmd = (best_Phi @ time_dynamics)[:n, :]\n        print(\n            f\"Warning: No r met the threshold. Using r={r_optimal} with max error {np.max(np.abs(X - best_Xdmd)):.6f}\"\n        )\n\n    return best_Phi, best_omega, best_lambda_vals, best_b, best_Xdmd, S_full, r_optimal\n</code></pre>"},{"location":"api/#slmemulator.SLM.solve_tov","title":"<code>solve_tov(fileName, tidal=False, parametric=False, mseos=True)</code>","text":"<p>Solves the TOV equation and returns radius, mass and central pressure</p> <p>Parameters:</p> Name Type Description Default <code>fileName</code> <code>str</code> <p>Filename containing the EOS in the format nb (fm^-3), E (MeV), P (MeV/fm^3)</p> required <p>Returns:</p> Name Type Description <code>dataArray</code> <code>array</code> <p>Data array containing radii, central pressure and mass.</p> Source code in <code>src/slmemulator/SLM.py</code> <pre><code>def solve_tov(fileName, tidal=False, parametric=False, mseos=True):\n    r\"\"\"\n    Solves the TOV equation and returns radius, mass and central pressure\n\n    Parameters:\n        fileName (str): Filename containing the EOS in the format nb (fm^-3),\n            E (MeV), P (MeV/fm^3)\n\n    Returns:\n        dataArray (array): Data array containing radii, central pressure\n            and mass.\n    \"\"\"\n    # Get current paths from the config module\n    paths = get_paths()\n\n    eos_file_path = None\n    tov_path_target = None\n\n    if parametric is False:\n        # Access EOS_Data as package resource\n        try:\n            slm_package_base = pkg_resources.files(_SLM_PACKAGE_NAME)\n            # Get a Path-like object to the EOS_Data file within the installed package\n            eos_file_path = pkg_resources.files(_INTERNAL_EOS_DATA_PATH).joinpath(\n                fileName\n            )\n            eos_data_resource_dir = slm_package_base.joinpath(\"EOS_Data\")\n            eos_file_path = eos_data_resource_dir.joinpath(fileName)\n            # When passing to TOV, ensure it's a string path if the solver expects it\n            file = TOV(str(eos_file_path), tidal=tidal)\n            tov_path_target = paths[\"tov_data_dir\"]\n        except FileNotFoundError:\n            raise FileNotFoundError(\n                f\"Internal EOS file '{fileName}' not found in package data.\"\n            )\n    else:\n        # Access EOS_files from external configured path\n        if mseos is True:\n            eos_file_path = paths[\"mseos_path\"] / fileName\n            tov_path_target = paths[\"mseos_tov_path\"]\n        else:\n            eos_file_path = paths[\"qeos_path\"] / fileName\n            tov_path_target = paths[\"qeos_tov_path\"]\n            print(\"Path:\", eos_file_path)\n\n        file = TOV(str(eos_file_path), tidal=tidal)  # Pass as string path\n\n    # Now tov_path_target is guaranteed to be assigned\n    if not tov_path_target.exists():\n        tov_path_target.mkdir(parents=True, exist_ok=True)\n\n    file.tov_routine(verbose=False, write_to_file=False)\n    print(\"R of 1.4 solar mass star: \", file.canonical_NS_radius())\n    dataArray = [\n        file.total_radius.flatten(),\n        file.total_pres_central.flatten(),\n        file.total_mass.flatten(),\n    ]\n    if tidal is True:\n        dataArray.append(file.k2.flatten())\n        # dataArray.append(file.tidal_deformability.flatten()[::-1])\n\n    dataArray = np.asarray(dataArray, dtype=np.float64)\n\n    # Construct the output filename more robustly\n    name_parts = os.path.basename(fileName).strip(\".txt\").split(\"_\")\n    print(\"Name parts:\", name_parts)\n    if len(name_parts) &gt; 2:\n        output_file_name = \"MR_\" + \"_\".join(name_parts[1:]) + \".txt\"\n    else:\n        output_file_name = \"_\".join([\"MR\", name_parts[0], \"TOV\"]) + \".txt\"\n\n    # Save directly to the target path without changing directory\n    output_full_path = tov_path_target / output_file_name\n    np.savetxt(output_full_path, dataArray.T, fmt=\"%1.8e\")\n    return dataArray\n</code></pre>"},{"location":"api/#slmemulator.cleanData","title":"<code>cleanData</code>","text":""},{"location":"api/#slmemulator.cleanData.clean_directory","title":"<code>clean_directory(directory: str = None)</code>","text":"<p>Cleans up specified files and directories within a given directory.</p> <p>directory (str): The path to the directory to clean. Defaults to the                  current working directory if None.</p> Source code in <code>src/slmemulator/cleanData.py</code> <pre><code>def clean_directory(directory: str = None):\n    \"\"\"\n    Cleans up specified files and directories within a given directory.\n\n    Parameters:\n    directory (str): The path to the directory to clean. Defaults to the\n                     current working directory if None.\n    \"\"\"\n    if directory is None:\n        directory = os.getcwd()\n\n    # Ensure the target directory exists and is a directory\n    target_dir_path = Path(directory).resolve()\n    if not target_dir_path.is_dir():\n        print(f\"Error: Directory '{directory}' not found or is not a directory.\")\n        return\n\n    print(f\"Cleaning directory: {target_dir_path}\")\n\n    # List of additional folders created by the code that you want to remove recursively.\n    # These are now relative to the 'directory' argument.\n    additional_folders_to_clean_names = [\n        DEFAULT_EOS_FILES_SUBDIR_NAME,\n        DEFAULT_RESULTS_SUBDIR_NAME,\n        DEFAULT_TOV_DATA_SUBDIR_NAME,\n        DEFAULT_TEST_DATA_SUBDIR_NAME,\n        DEFAULT_TRAIN_DATA_SUBDIR_NAME,\n        DEFAULT_PLOTS_SUBDIR_NAME,\n    ]\n\n    # Convert these names to full paths within the target directory\n    additional_folders_to_clean_paths = [\n        target_dir_path / name for name in additional_folders_to_clean_names\n    ]\n\n    for root, dirs, files in os.walk(\n        target_dir_path, topdown=False\n    ):  # Traverse from bottom to top\n        # Clean files matching patterns in cleanup_targets\n        for file in files:\n            for target_ext in [\n                t for t in cleanup_targets if t.startswith(\".\")\n            ]:  # Only check extensions\n                if file.endswith(target_ext):\n                    file_path = os.path.join(root, file)\n                    print(f\"Removing file: {file_path}\")\n                    os.remove(file_path)\n\n        # Clean directories matching patterns in cleanup_targets (by name)\n        # or directories matching full paths in additional_folders_to_clean_paths\n        for dir_name in dirs:\n            dir_full_path = Path(root) / dir_name  # Use Path for comparison\n            if (\n                dir_name in cleanup_targets\n                or dir_full_path in additional_folders_to_clean_paths\n            ):\n                print(f\"Removing directory: {dir_full_path}\")\n                shutil.rmtree(dir_full_path)\n</code></pre>"},{"location":"api/#slmemulator.config","title":"<code>config</code>","text":""},{"location":"api/#slmemulator.config.get_paths","title":"<code>get_paths(output_base_dir: Path = None, use_mseos: bool = True, is_parametric_run: bool = True) -&gt; dict</code>","text":"<p>Returns a dictionary of resolved paths for data input/output and other project directories. Prioritizes explicit arguments for output_base_dir, then sensible defaults. Conditionally sets 'current' EOS/TOV/results paths based on the use_mseos flag. Adjusts base for general data directories (EOS_Data, TOV_data, testData, trainData) to output_base_dir if provided (for local working directories), otherwise defaults them to be under src_dir (for package internal use).</p> <p>Parameters:</p> Name Type Description Default <code>output_base_dir</code> <code>Path</code> <p>The base directory for all generated outputs.                              Defaults to the project root.</p> <code>None</code> <code>use_mseos</code> <code>bool</code> <p>If True, 'current' paths will point to MSEOS-related directories.               If False, 'current' paths will point to QEOS-related directories.               Defaults to True.</p> <code>True</code> <code>is_parametric_run</code> <code>bool</code> <p>If True, indicates a parametric run.                       This parameter is available for future path logic,                       but currently the primary factor for                       data directory location is <code>output_base_dir</code>.                       Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing all relevant path configurations.</p> Source code in <code>src/slmemulator/config.py</code> <pre><code>def get_paths(\n    output_base_dir: Path = None,\n    use_mseos: bool = True,\n    is_parametric_run: bool = True,\n) -&gt; dict:\n    \"\"\"\n    Returns a dictionary of resolved paths for data input/output and other project directories.\n    Prioritizes explicit arguments for output_base_dir, then sensible defaults.\n    Conditionally sets 'current' EOS/TOV/results paths based on the use_mseos flag.\n    Adjusts base for general data directories (EOS_Data, TOV_data, testData, trainData)\n    to output_base_dir if provided (for local working directories),\n    otherwise defaults them to be under src_dir (for package internal use).\n\n    Args:\n        output_base_dir (Path, optional): The base directory for all generated outputs.\n                                         Defaults to the project root.\n        use_mseos (bool): If True, 'current' paths will point to MSEOS-related directories.\n                          If False, 'current' paths will point to QEOS-related directories.\n                          Defaults to True.\n        is_parametric_run (bool): If True, indicates a parametric run.\n                                  This parameter is available for future path logic,\n                                  but currently the primary factor for\n                                  data directory location is `output_base_dir`.\n                                  Defaults to True.\n\n    Returns:\n        dict: A dictionary containing all relevant path configurations.\n    \"\"\"\n    # Use explicit output_base_dir or default to the calculated PROJECT_ROOT\n    output_base = output_base_dir or PROJECT_ROOT\n\n    # src_dir will always be under the primary base (output_base or PROJECT_ROOT)\n    src_dir = output_base / DEFAULT_SRC_SUBDIR_NAME\n\n    # Determine the base for general data directories (EOS_Data, TOV_data, testData, trainData)\n    # If output_base_dir is explicitly provided, these data directories should be\n    # relative to it. Otherwise, they remain within the src_dir of the package.\n    if output_base_dir is not None:\n        data_root_dir = output_base\n    else:\n        data_root_dir = src_dir\n\n    paths = {\n        \"project_root\": output_base,\n        \"src_dir\": src_dir,\n        # EOS_Codes_dir should point to the location within the *installed package*\n        # This ensures that whether installed or in editable mode, it finds the right place.\n        \"eos_codes_dir\": pkg_resources.files(\"slmemulator\").joinpath(\n            DEFAULT_EOS_CODES_SUBDIR_NAME\n        ),\n        \"plots_dir\": data_root_dir / DEFAULT_PLOTS_SUBDIR_NAME,\n        \"results_dir\": data_root_dir / DEFAULT_RESULTS_SUBDIR_NAME,\n        \"docs_dir\": output_base / DEFAULT_DOCS_SUBDIR_NAME,\n        \"tests_dir\": output_base / DEFAULT_TESTS_SUBDIR_NAME,\n        \"tutorials_dir\": output_base / DEFAULT_TUTORIALS_SUBDIR_NAME,\n        # Data directories whose location depends on `output_base_dir`\n        \"eos_data_dir\": data_root_dir\n        / DEFAULT_EOS_DATA_SUBDIR_NAME,  # For user-provided/existing EOS data\n        \"tov_data_dir\": data_root_dir / DEFAULT_TOV_DATA_SUBDIR_NAME,\n        \"test_data_dir\": data_root_dir / DEFAULT_TEST_DATA_SUBDIR_NAME,\n        \"train_path\": data_root_dir / DEFAULT_TRAIN_DATA_SUBDIR_NAME,\n        # EOS_files_dir contains generated EOS files (MSEOS/QEOS subdirs)\n        # This is where output of MSEOS.py/Quarkyonia.py goes, typically under src/\n        \"eos_files_dir\": data_root_dir / DEFAULT_EOS_FILES_SUBDIR_NAME,\n        \"eos_data_dir\": pkg_resources.files(\"slmemulator\").joinpath(\n            DEFAULT_EOS_DATA_SUBDIR_NAME\n        ),\n        # Specific paths for QEOS and MSEOS (always defined relative to their respective bases)\n        \"qeos_path_specific\": (data_root_dir / DEFAULT_EOS_FILES_SUBDIR_NAME) / \"QEOS\",\n        \"mseos_path_specific\": (data_root_dir / DEFAULT_EOS_FILES_SUBDIR_NAME)\n        / \"MSEOS\",\n        # Correcting specific TOV data paths to use data_root_dir (for user data)\n        \"qeos_tov_path_specific\": (data_root_dir / DEFAULT_TOV_DATA_SUBDIR_NAME)\n        / \"QEOS\",\n        \"mseos_tov_path_specific\": (data_root_dir / DEFAULT_TOV_DATA_SUBDIR_NAME)\n        / \"MSEOS\",\n        # General SLM specific result/plot subdirectories (non-parametric)\n        \"slm_res_mseos_specific\": (\n            data_root_dir\n            / DEFAULT_RESULTS_SUBDIR_NAME\n            / \"MSEOS\"\n            / DEFAULT_SLM_SUBDIR_NAME\n        ),\n        \"slm_res_qeos_specific\": (\n            data_root_dir\n            / DEFAULT_RESULTS_SUBDIR_NAME\n            / \"QEOS\"\n            / DEFAULT_SLM_SUBDIR_NAME\n        ),\n        \"slm_plots_mseos_specific\": (\n            data_root_dir\n            / DEFAULT_PLOTS_SUBDIR_NAME\n            / \"MSEOS\"\n            / DEFAULT_SLM_SUBDIR_NAME\n        ),\n        \"slm_plots_qeos_specific\": (\n            data_root_dir / DEFAULT_PLOTS_SUBDIR_NAME / \"QEOS\" / DEFAULT_SLM_SUBDIR_NAME\n        ),\n        # Parametric SLM specific result/plot subdirectories\n        \"slm_res_mseos_parametric_specific\": (\n            data_root_dir\n            / DEFAULT_RESULTS_SUBDIR_NAME\n            / \"MSEOS\"\n            / DEFAULT_PSLM_SUBDIR_NAME\n        ),\n        \"slm_res_qeos_parametric_specific\": (\n            data_root_dir\n            / DEFAULT_RESULTS_SUBDIR_NAME\n            / \"QEOS\"\n            / DEFAULT_PSLM_SUBDIR_NAME\n        ),\n        \"slm_plots_mseos_parametric_specific\": (\n            data_root_dir\n            / DEFAULT_PLOTS_SUBDIR_NAME\n            / \"MSEOS\"\n            / DEFAULT_PSLM_SUBDIR_NAME\n        ),\n        \"slm_plots_qeos_parametric_specific\": (\n            data_root_dir\n            / DEFAULT_PLOTS_SUBDIR_NAME\n            / \"QEOS\"\n            / DEFAULT_PSLM_SUBDIR_NAME\n        ),\n    }\n\n    # Conditionally set the \"current\" paths based on the use_mseos flag AND `is_parametric_run`\n    if use_mseos:\n        paths[\"current_eos_input_dir\"] = paths[\"mseos_path_specific\"]\n        paths[\"current_tov_data_dir\"] = paths[\"mseos_tov_path_specific\"]\n        if is_parametric_run:\n            paths[\"current_slm_results_dir\"] = paths[\n                \"slm_res_mseos_parametric_specific\"\n            ]\n            paths[\"current_slm_plots_dir\"] = paths[\n                \"slm_plots_mseos_parametric_specific\"\n            ]\n        else:  # Non-parametric SLM run for MSEOS\n            paths[\"current_slm_results_dir\"] = paths[\"slm_res_mseos_specific\"]\n            paths[\"current_slm_plots_dir\"] = paths[\"slm_plots_mseos_specific\"]\n    else:  # QEOS\n        paths[\"current_eos_input_dir\"] = paths[\"qeos_path_specific\"]\n        paths[\"current_tov_data_dir\"] = paths[\"qeos_tov_path_specific\"]\n        if is_parametric_run:\n            paths[\"current_slm_results_dir\"] = paths[\"slm_res_qeos_parametric_specific\"]\n            paths[\"current_slm_plots_dir\"] = paths[\"slm_plots_qeos_parametric_specific\"]\n        else:  # Non-parametric SLM run for QEOS\n            paths[\"current_slm_results_dir\"] = paths[\"slm_res_qeos_specific\"]\n            paths[\"current_slm_plots_dir\"] = paths[\"slm_plots_qeos_specific\"]\n\n    # Ensure all paths are Path objects\n    return {k: Path(v) for k, v in paths.items()}\n</code></pre>"},{"location":"api/#slmemulator.pSLM","title":"<code>pSLM</code>","text":""},{"location":"api/#slmemulator.pSLM.ParametricSLM","title":"<code>ParametricSLM(fileList, filePath, tidal=False, error_threshold=0.0001, max_r=None)</code>","text":"Source code in <code>src/slmemulator/pSLM.py</code> <pre><code>def __init__(\n    self, fileList, filePath, tidal=False, error_threshold=1e-4, max_r=None\n):\n    # fileList is expected to be a list of Path objects from testpSLM.py\n    self.fileList = [Path(f) for f in fileList]  # Ensure all are Path objects\n    self.filePath = Path(filePath)  # Ensure filePath is a Path object\n    self.tidal = tidal\n    self.error_threshold = error_threshold\n    self.max_r = max_r\n    self.n = None  # Number of quantities/rows in the data X\n    self.mm1 = (\n        None  # Number of time points/columns in the data X (m-1 snapshots for DMD)\n    )\n\n    # Lists to store DMD components for each training file\n    self.Phi_list = []\n    self.omega_list = []\n    self.D_list = []\n    self.b_list = []\n    self.train_data_shapes = []  # Store shapes (n, mm1) of training data\n\n    # Store extracted parameters for each file, in the same order as fileList\n    self.file_params = []\n    self.param_scaler = None  # Scaler for parameters, fitted in .fit()\n    self.scaled_params = None  # Scaled parameters of training data\n</code></pre>"},{"location":"api/#slmemulator.pSLM.ParametricSLM.augment_data","title":"<code>augment_data(X)</code>  <code>staticmethod</code>","text":"<p>Augments the input data X by adding quadratic terms (X_i * X_j).</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Original data matrix (n, m).</p> required <p>Returns:</p> Type Description <p>np.ndarray (np.ndarray): Augmented data matrix.</p> Source code in <code>src/slmemulator/pSLM.py</code> <pre><code>@staticmethod\ndef augment_data(X):\n    \"\"\"\n    Augments the input data X by adding quadratic terms (X_i * X_j).\n\n    Parameters:\n        X (np.ndarray): Original data matrix (n, m).\n\n    Returns:\n        np.ndarray (np.ndarray): Augmented data matrix.\n    \"\"\"\n    n, m = X.shape\n    out = [X]\n    # Add quadratic terms (combinations with replacement of rows of X)\n    for i, j in combinations_with_replacement(range(n), 2):\n        out.append(X[i] * X[j])\n    # Add cubic terms if needed (example commented out)\n    # for i, j, k in combinations_with_replacement(range(n), 3):\n    #     out.append(X[i] * X[j] * X[k])\n    return np.vstack(out)\n</code></pre>"},{"location":"api/#slmemulator.pSLM.ParametricSLM.fit","title":"<code>fit()</code>","text":"<p>Fits the Parametric SLM model by processing each file in fileList, performing DMD, and storing the DMD components along with extracted parameters.</p> Source code in <code>src/slmemulator/pSLM.py</code> <pre><code>def fit(self):\n    \"\"\"\n    Fits the Parametric SLM model by processing each file in fileList,\n    performing DMD, and storing the DMD components along with extracted parameters.\n    \"\"\"\n    self.Phi_list = []\n    self.omega_list = []\n    self.D_list = []\n    self.b_list = []\n    self.file_params = []  # Reset for clarity, though init should handle it\n    self.train_data_shapes = []  # Store shapes for consistency check in predict\n\n    processed_files_count = 0\n    for file_path_obj in self.fileList:  # Iterate through Path objects\n        # Validate file_path_obj is a Path object and exists\n        if not isinstance(file_path_obj, Path) or not file_path_obj.exists():\n            print(f\"Skipping invalid or non-existent file: {file_path_obj}\")\n            continue\n\n        # Extract parameters from the filename (e.g., TOV_MS_Ls_Lv_zeta_xi.txt)\n        # We assume the file name format is consistent with _extract_params_from_tov_filename\n        # We determine mseos based on 'MS' or 'QEOS' in the filename\n        is_mseos = \"MS\" in file_path_obj.stem  # Check if filename contains 'MS'\n        # Call the static method using self.\n        params = self._extract_params_from_tov_filename(\n            file_path_obj.stem, is_mseos\n        )\n\n        if params is None:  # _extract_params_from_tov_filename prints warning\n            continue  # Skip if parameters could not be extracted\n\n        try:\n            # Load data from the file\n            # The file is a Path object, np.loadtxt can directly handle it\n            data = np.loadtxt(file_path_obj)\n\n            if not np.all(np.isfinite(data)):\n                print(\n                    f\"Skipping {file_path_obj.name}: contains NaN or Inf values. Please check data quality.\"\n                )\n                continue\n\n            # Process data (assuming data has columns like Radius, Mass, etc.)\n            # X should be (num_quantities, num_points)\n            epsilon = 1e-9  # Small constant to prevent log(0)\n            if self.tidal:\n                # Assuming 4 columns: Radius, Mass, Central Pressure, Tidal Deformability\n                # Ensure data has at least 4 columns\n                if data.shape[1] &lt; 4:\n                    print(\n                        f\"Skipping {file_path_obj.name}: Expected at least 4 columns for tidal data, got {data.shape[1]}.\"\n                    )\n                    continue\n                X = np.log(data[:, [0, 1, 2, 3]].T + epsilon)\n            else:\n                # Assuming 3 columns: Radius, Mass, Central Pressure (or other relevant)\n                # Ensure data has at least 3 columns\n                if data.shape[1] &lt; 3:\n                    print(\n                        f\"Skipping {file_path_obj.name}: Expected at least 3 columns for non-tidal data, got {data.shape[1]}.\"\n                    )\n                    continue\n                X = np.log(data[:, [0, 1, 2]].T + epsilon)\n\n            X = np.asarray(\n                X, dtype=np.float64\n            )  # Ensure float64 for numerical stability\n\n            # Store shape for consistency checks in predict\n            if (\n                self.n is None\n            ):  # Only set for the very first successfully processed file\n                self.n, self.mm1 = X.shape[0], X.shape[1]\n                self.augmented_n = self.augment_data(\n                    np.zeros((self.n, self.mm1))\n                ).shape[0]\n            elif X.shape[0] != self.n or X.shape[1] != self.mm1:\n                print(\n                    f\"Warning: {file_path_obj.name} has inconsistent shape {X.shape}. Expected ({self.n}, {self.mm1}). Skipping.\"\n                )\n                continue  # Skip files with inconsistent shapes for DMD\n\n            dt = 1.0  # Assuming uniform time step of 1.0 between data points\n            result = self._SLM_auto_r(X, dt)  # Perform SLM and get optimal rank\n\n            # Check if SLM_auto_r returned a valid result\n            if result[\"err\"] == float(\"inf\"):\n                print(\n                    f\"Failed to fit SLM model for {file_path_obj.name}. Skipping.\"\n                )\n                continue\n\n            # Store DMD components and parameters for successful fits\n            self.Phi_list.append(result[\"Phi\"])\n            self.omega_list.append(result[\"omega\"])\n            self.D_list.append(result[\"D\"])\n            self.b_list.append(result[\"b\"])\n            self.file_params.append(\n                params\n            )  # Store parameters for the processed file\n            self.train_data_shapes.append(\n                X.shape\n            )  # Store shape for this specific training data\n\n            processed_files_count += 1\n            # print(f\"Successfully processed {file_path_obj.name}. Max error: {result['err']:.4e}\")\n\n        except Exception as e:\n            print(f\"Error processing file {file_path_obj.name}: {e}. Skipping.\")\n            continue\n\n    if processed_files_count == 0:\n        raise RuntimeError(\n            \"No valid training files processed! Please check your input data and `error_threshold`.\"\n        )\n\n    # Fit StandardScaler on the collected parameters\n    self.params = np.array(self.file_params)\n    self.param_scaler = StandardScaler().fit(self.params)\n    self.scaled_params = self.param_scaler.transform(self.params)\n</code></pre>"},{"location":"api/#slmemulator.pSLM.ParametricSLM.predict","title":"<code>predict(param_values, k=1, output_interp=False, distance_threshold=None)</code>","text":"<p>Predicts the dynamics (Xdmd) for a given set of parameters by finding nearest neighbors in the parameter space and averaging their DMD components or using the closest one.</p> <p>Parameters:</p> Name Type Description Default <code>param_values</code> <code>list or ndarray</code> <p>A list or array of parameter values to predict for                                          (e.g., [Ls, Lv, zeta, xi] for MSEOS). This argument is mandatory.</p> required <code>k</code> <code>int</code> <p>Number of nearest neighbors to use for prediction.      Defaults to 1 (pure nearest neighbor).</p> <code>1</code> <code>output_interp</code> <code>bool</code> <p>If True, interpolate the final Xdmd outputs by averaging curves.                   If False (default) and k&gt;1, averages the DMD components (Phi, omega, D, b).</p> <code>False</code> <code>distance_threshold</code> <code>float</code> <p>If the distance to the closest neighbor                                   exceeds this threshold, a warning is printed.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(Phi_avg/Phi_nn, omega_avg/omega_nn, D_avg/D_nn, b_avg/b_nn, Xdmd_predicted, t)    - Reconstructed data (Xdmd_predicted) and related averaged DMD components.</p> <p>Raises:     ValueError: If the model has not been fitted or no training data is available.</p> Source code in <code>src/slmemulator/pSLM.py</code> <pre><code>def predict(self, param_values, k=1, output_interp=False, distance_threshold=None):\n    \"\"\"\n    Predicts the dynamics (Xdmd) for a given set of parameters by finding nearest neighbors\n    in the parameter space and averaging their DMD components or using the closest one.\n\n    Parameters:\n        param_values (list or np.ndarray): A list or array of parameter values to predict for\n                                                     (e.g., [Ls, Lv, zeta, xi] for MSEOS). This argument is mandatory.\n        k (int): Number of nearest neighbors to use for prediction.\n                 Defaults to 1 (pure nearest neighbor).\n        output_interp (bool): If True, interpolate the final Xdmd outputs by averaging curves.\n                              If False (default) and k&gt;1, averages the DMD components (Phi, omega, D, b).\n        distance_threshold (float, optional): If the distance to the closest neighbor\n                                              exceeds this threshold, a warning is printed.\n\n    Returns:\n        tuple: (Phi_avg/Phi_nn, omega_avg/omega_nn, D_avg/D_nn, b_avg/b_nn, Xdmd_predicted, t)\n               - Reconstructed data (Xdmd_predicted) and related averaged DMD components.\n    Raises:\n        ValueError: If the model has not been fitted or no training data is available.\n    \"\"\"\n    if not self.Phi_list:\n        raise ValueError(\"Model not fitted. Call .fit() first.\")\n    if not self.file_params:\n        raise ValueError(\"No training data parameters available from fit().\")\n\n    # If param_values are provided (the main use case for prediction)\n    theta = np.asarray(param_values, dtype=np.float64)\n\n    # Scale the input parameters using the fitted scaler\n    try:\n        scaled_theta = self.param_scaler.transform([theta])[0]\n    except ValueError as e:\n        raise ValueError(\n            f\"Parameter scaling failed for {theta}. Ensure input matches training dimensions. Error: {e}\"\n        )\n\n    # Calculate Euclidean distances to all scaled training parameters\n    dists = np.linalg.norm(self.scaled_params - scaled_theta, axis=1)\n\n    # Get indices of k smallest distances\n    # Ensure k does not exceed the number of available training samples\n    k_actual = min(k, len(self.file_params))\n    if k_actual == 0:\n        raise ValueError(\"No training data available to make a prediction.\")\n\n    sorted_indices = np.argsort(dists)\n    idxs = sorted_indices[:k_actual]\n\n    # Check if the closest neighbor is too far (optional warning/handling)\n    if distance_threshold is not None and dists[idxs[0]] &gt; distance_threshold:\n        print(\n            f\"Warning: Closest neighbor distance ({dists[idxs[0]]:.4f}) exceeds threshold ({distance_threshold}). \"\n            f\"Prediction might be unreliable for parameters {param_values}.\"\n        )\n\n    # Use the shape of the training data corresponding to the first nearest neighbor\n    # as the reference shape for reconstruction (assuming consistency)\n    if not self.train_data_shapes:\n        raise ValueError(\n            \"Training data shapes not recorded during fit(). Cannot predict.\"\n        )\n\n    # Use the original (non-augmented) shape of training data for reconstruction\n    ref_n_original, ref_mm1_original = self.train_data_shapes[\n        idxs[0]\n    ]  # Use shape from first nearest neighbor\n\n    dt = 1.0  # Assuming original dt=1.0\n\n    if output_interp and k_actual &gt; 1:\n        # Option 1: Interpolate outputs by averaging reconstructed curves\n        curves = []\n        for idx in idxs:\n            Phi = self.Phi_list[idx]\n            omega = self.omega_list[idx]\n            b = self.b_list[idx]\n\n            t_reconstruction = np.arange(ref_mm1_original) * dt\n            time_dynamics = b[:, np.newaxis] * np.exp(\n                omega[:, np.newaxis] * t_reconstruction[np.newaxis, :]\n            )\n            Xdmd_full_aug = Phi @ time_dynamics\n            Xdmd = Xdmd_full_aug[\n                :ref_n_original, :\n            ]  # Trim back to original dimensions\n            curves.append(Xdmd)\n\n        Xdmd_predicted = np.mean(curves, axis=0)  # Average the reconstructed curves\n\n        # For consistency, return averaged DMD components even if output is interpolated\n        Phi_avg = np.mean([self.Phi_list[i] for i in idxs], axis=0)\n        omega_avg = np.mean([self.omega_list[i] for i in idxs], axis=0)\n        D_avg = np.mean([self.D_list[i] for i in idxs], axis=0)\n        b_avg = np.mean([self.b_list[i] for i in idxs], axis=0)\n\n        return (Phi_avg, omega_avg, D_avg, b_avg, Xdmd_predicted, t_reconstruction)\n\n    else:\n        # Option 2: Average DMD components (Phi, omega, D, b) from k nearest neighbors\n        # (or just use the single nearest neighbor if k=1 or output_interp is False)\n        Phi_avg = np.mean([self.Phi_list[i] for i in idxs], axis=0)\n        omega_avg = np.mean([self.omega_list[i] for i in idxs], axis=0)\n        D_avg = np.mean([self.D_list[i] for i in idxs], axis=0)\n        b_avg = np.mean([self.b_list[i] for i in idxs], axis=0)\n\n        t_reconstruction = (\n            np.arange(ref_mm1_original) * dt\n        )  # Time points for prediction\n        time_dynamics = b_avg[:, np.newaxis] * np.exp(\n            omega_avg[:, np.newaxis] * t_reconstruction[np.newaxis, :]\n        )\n        Xdmd_full_aug = Phi_avg @ time_dynamics\n        Xdmd_predicted = Xdmd_full_aug[\n            :ref_n_original, :\n        ]  # Trim back to original dimensions\n\n        return (Phi_avg, omega_avg, D_avg, b_avg, Xdmd_predicted, t_reconstruction)\n</code></pre>"},{"location":"api/#slmemulator.pSLM.is_on_boundary","title":"<code>is_on_boundary(param, param_min, param_max, tolerance=1e-05)</code>","text":"<p>Checks if a parameter set is on the boundary of the parameter space.</p> Source code in <code>src/slmemulator/pSLM.py</code> <pre><code>def is_on_boundary(param, param_min, param_max, tolerance=1e-5):\n    \"\"\"Checks if a parameter set is on the boundary of the parameter space.\"\"\"\n    for i in range(len(param)):\n        if (\n            abs(param[i] - param_min[i]) &lt; tolerance\n            or abs(param[i] - param_max[i]) &lt; tolerance\n        ):\n            return True\n    return False\n</code></pre>"},{"location":"api/#slmemulator.recombination","title":"<code>recombination</code>","text":""},{"location":"api/#slmemulator.recombination.gaussian_rbf","title":"<code>gaussian_rbf(r, epsilon)</code>","text":"<p>Gaussian Radial Basis Function.</p> Source code in <code>src/slmemulator/recombination.py</code> <pre><code>def gaussian_rbf(r, epsilon):\n    \"\"\"Gaussian Radial Basis Function.\"\"\"\n    return np.exp(-((epsilon * r) ** 2))\n</code></pre>"},{"location":"api/#slmemulator.recombination.recombination_thinning","title":"<code>recombination_thinning(A_matrix, y_vector, initial_solution_x=None, tolerance=1e-09)</code>","text":"<p>Conceptual implementation of the recombination thinning process based on the paper. This function aims to find a sparse solution x' to the linear system Ax = y.</p> <p>Parameters:</p> Name Type Description Default <code>A_matrix</code> <code>array</code> <p>The matrix A in the linear system Ax = y.                  In the context of GRIM, this matrix relates features and                  linear functionals.</p> required <code>y_vector</code> <code>array</code> <p>The vector y in the linear system Ax = y.                  In the context of GRIM, this relates to the target function                  evaluated by linear functionals.</p> required <code>initial_solution_x</code> <code>array</code> <p>An initial solution vector x. If None,                                       a least squares solution is computed.</p> <code>None</code> <code>tolerance</code> <code>float</code> <p>Tolerance for numerical stability, especially for SVD and                checking non-zero components.</p> <code>1e-09</code> <p>Returns:</p> Type Description <p>np.array: A sparser solution vector x' for the system Ax = y.       Returns None if the system is inconsistent or other issues.</p> Source code in <code>src/slmemulator/recombination.py</code> <pre><code>def recombination_thinning(A_matrix, y_vector, initial_solution_x=None, tolerance=1e-9):\n    \"\"\"\n    Conceptual implementation of the recombination thinning process based on the paper.\n    This function aims to find a sparse solution x' to the linear system Ax = y.\n\n    Parameters:\n        A_matrix (np.array): The matrix A in the linear system Ax = y.\n                             In the context of GRIM, this matrix relates features and\n                             linear functionals.\n        y_vector (np.array): The vector y in the linear system Ax = y.\n                             In the context of GRIM, this relates to the target function\n                             evaluated by linear functionals.\n        initial_solution_x (np.array, optional): An initial solution vector x. If None,\n                                                  a least squares solution is computed.\n        tolerance (float): Tolerance for numerical stability, especially for SVD and\n                           checking non-zero components.\n\n    Returns:\n        np.array: A sparser solution vector x' for the system Ax = y.\n                  Returns None if the system is inconsistent or other issues.\n    \"\"\"\n\n    if A_matrix.shape[0] != y_vector.shape[0]:\n        raise ValueError(\"Dimensions of A_matrix and y_vector are not compatible.\")\n\n    # 2. Find an initial solution x if not provided\n    if initial_solution_x is None:\n        try:\n            initial_solution_x = np.linalg.lstsq(A_matrix, y_vector, rcond=None)[0]\n        except np.linalg.LinAlgError:\n            print(\n                \"Warning: Least squares solution failed for initial_solution_x. Returning None.\"\n            )\n            return None\n\n    # The `recombination_thinning` as provided aims to return an initial least squares solution.\n    # For more advanced thinning/sparsity, additional iterative logic or L1 regularization\n    # would typically be integrated here. As per your provided `bgrim.py` and prior discussions,\n    # we are using this function's current behavior.\n    return initial_solution_x\n</code></pre>"},{"location":"api/#slmemulator.scaledTOV","title":"<code>scaledTOV</code>","text":"<p>Information about the code: This code solves TOV equations for mass radius relations. This can also plot the mass-radius curve.</p> <p>USE: To use the code, here are the steps: 1) Include the file in your main code e.g. import tov_class as tc 2) Load the EoS using the ToV loader, tc.ToV(filename, arraysize) 3) call the solver as tc.ToV.mass_radius(min_pressure, max_pressure) 4) To plot, follow the code in main() on creating the dictionary of inputs</p> <p>Updates: Version 0.0.1-1 Solves ToV, can only take inputs of pressure (MeV/fm^3), energy density in MeV, baryon density in fm^-3 in ascending order.</p>"},{"location":"api/#slmemulator.scaledTOV.TOV","title":"<code>TOV(filename, imax)</code>","text":"<p>Solves TOV equations and gives data-table, mass-radius plot and max. mass, central pressure and central density by loading an EoS datafile.</p> Source code in <code>src/slmemulator/scaledTOV.py</code> <pre><code>def __init__(self, filename, imax):\n    self.file = np.loadtxt(filename, skiprows=3)\n    self.e_in = self.file[:, 1] / eps0  # Scaled Energy density\n    self.p_in = self.file[:, 2] / pres0  # Scaled pressure\n    self.nb_in = self.file[:, 0]\n    self.imax = imax\n    self.radius = np.empty(self.imax)\n    self.mass = np.empty(self.imax)\n</code></pre>"},{"location":"api/#slmemulator.scaledTOV.TOV.pressure_from_nb","title":"<code>pressure_from_nb(nb)</code>","text":"<p>Evaluate pressure from number density using interpolation</p> Source code in <code>src/slmemulator/scaledTOV.py</code> <pre><code>def pressure_from_nb(self, nb):\n    \"\"\"Evaluate pressure from number density using interpolation\"\"\"\n    p1 = interp1d(\n        self.nb_in, self.p_in, axis=0, kind=\"linear\", fill_value=\"extrapolate\"\n    )\n    return p1(nb)\n</code></pre>"},{"location":"api/#slmemulator.scaledTOV.TOV.energy_from_pressure","title":"<code>energy_from_pressure(pressure)</code>","text":"<p>Evaluate energy density from pressure using interpolation</p> Source code in <code>src/slmemulator/scaledTOV.py</code> <pre><code>def energy_from_pressure(self, pressure):\n    \"\"\"Evaluate energy density from pressure using interpolation\"\"\"\n    plow = 1e-10 / pres0\n    if pressure &lt; plow:\n        return 2.6e-310\n    else:\n        e1 = interp1d(\n            self.p_in, self.e_in, axis=0, kind=\"linear\", fill_value=\"extrapolate\"\n        )\n        return e1(pressure)\n</code></pre>"},{"location":"api/#slmemulator.scaledTOV.TOV.pressure_from_energy","title":"<code>pressure_from_energy(energy)</code>","text":"<p>Evaluate pressure from energy density using interpolation</p> Source code in <code>src/slmemulator/scaledTOV.py</code> <pre><code>def pressure_from_energy(self, energy):\n    \"\"\"Evaluate pressure from energy density using interpolation\"\"\"\n    p1 = interp1d(\n        self.e_in, self.p_in, axis=0, kind=\"linear\", fill_value=\"extrapolate\"\n    )\n    return p1(energy)\n</code></pre>"},{"location":"api/#slmemulator.scaledTOV.TOV.baryon_from_energy","title":"<code>baryon_from_energy(energy)</code>","text":"<p>Evaluate number density from energy using interpolation</p> Source code in <code>src/slmemulator/scaledTOV.py</code> <pre><code>def baryon_from_energy(self, energy):\n    \"\"\"Evaluate number density from energy using interpolation\"\"\"\n    n1 = interp1d(\n        self.e_in, self.nb_in, axis=0, kind=\"linear\", fill_value=\"extrapolate\"\n    )\n    return n1(energy)\n</code></pre>"},{"location":"api/#slmemulator.scaledTOV.TOV.RK4","title":"<code>RK4(f, x0, t0, te, N)</code>","text":"<p>A simple RK4 solver to avoid overhead of calculating with solve_ivp or any other adaptive step-size function.</p> Example <p>tov.RK4(f=func, x0=1., t0=1., te=10., N=100)</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>func</code> <p>A Python function for the ODE(s) to be solved. Able to solve N coupled ODEs.</p> required <code>x0</code> <code>float</code> <p>Guess for the function(s) to be solved.</p> required <code>t0</code> <code>float</code> <p>Initial point of the grid.</p> required <code>te</code> <code>float</code> <p>End point of the grid.</p> required <code>N</code> <code>int</code> <p>The number of steps to take in the range (te-t0).</p> required <p>Returns:</p> Name Type Description <code>times</code> <code>array</code> <p>The grid of solution steps.</p> <code>solution</code> <code>array</code> <p>The solutions of each function at each point in the grid.</p> Source code in <code>src/slmemulator/scaledTOV.py</code> <pre><code>def RK4(self, f, x0, t0, te, N):\n    r\"\"\"\n    A simple RK4 solver to avoid overhead of\n    calculating with solve_ivp or any other\n    adaptive step-size function.\n\n    Example:\n        tov.RK4(f=func, x0=1., t0=1., te=10., N=100)\n\n    Parameters:\n        f (func): A Python function for the ODE(s) to be solved.\n            Able to solve N coupled ODEs.\n\n        x0 (float): Guess for the function(s) to be solved.\n\n        t0 (float): Initial point of the grid.\n\n        te (float): End point of the grid.\n\n        N (int): The number of steps to take in the range (te-t0).\n\n    Returns:\n        times (array): The grid of solution steps.\n\n        solution (array): The solutions of each function\n            at each point in the grid.\n    \"\"\"\n\n    h = (te - t0) / N\n    times = np.arange(t0, te + h, h)\n    solution = []\n    x = x0\n\n    for t in times:\n        solution.append(np.array(x).T)\n        k1 = h * f(t, x)\n        k2 = h * f(t + 0.5 * h, x + 0.5 * k1)\n        k3 = h * f(t + 0.5 * h, x + 0.5 * k2)\n        k4 = h * f(t + h, x + k3)\n        x += (k1 + 2 * (k2 + k3) + k4) / 6\n\n    solution = np.asarray(solution, dtype=np.float64).T\n\n    return times, solution\n</code></pre>"},{"location":"api/#slmemulator.TOV_class","title":"<code>TOV_class</code>","text":""},{"location":"api/#slmemulator.TOV_class.TOV","title":"<code>TOV(eos_filepath=None, tidal=False, solver='RK4', solve_ivp_kwargs=None, sol_pts=4000)</code>","text":"<p>inertia using RK4. Also includes uncertainty quantification techniques through the highest posterior density interval (HPD or HDI) calculation. Able to accept one EOS from a single curve or draws from an EOS, such as from a Gaussian Process.</p> Example <p>tov = TOVSolver(eos_filepath='path/to/eos', tidal=True, moment=True)</p> <p>Parameters:</p> Name Type Description Default <code>eos_filepath</code> <code>str</code> <p>The path to the EOS data table to be used.</p> <code>None</code> <code>tidal</code> <code>bool</code> <p>Whether to calculate tidal deformability or not. Default is False.</p> <code>False</code> <code>moment</code> <code>bool</code> <p>Whether to calculate moment of inertia or not. Default is False.</p> required <p>Returns:</p> Type Description <p>None.</p> Source code in <code>src/slmemulator/TOV_class.py</code> <pre><code>def __init__(\n    self,\n    eos_filepath=None,\n    tidal=False,\n    solver=\"RK4\",\n    solve_ivp_kwargs=None,\n    sol_pts=4000,\n):\n    r\"\"\"\n    Class to calculate the Tolman-Oppenheimer-Volkoff equations,\n    including options for the tidal deformability and moment of\n    inertia using RK4. Also includes uncertainty quantification\n    techniques through the highest posterior density interval (HPD\n    or HDI) calculation. Able to accept one EOS from a single curve\n    or draws from an EOS, such as from a Gaussian Process.\n\n    Example:\n        tov = TOVSolver(eos_filepath='path/to/eos', tidal=True, moment=True)\n\n    Parameters:\n        eos_filepath (str): The path to the EOS data table to be used.\n\n        tidal (bool): Whether to calculate tidal deformability or not.\n            Default is False.\n\n        moment (bool): Whether to calculate moment of inertia or not.\n            Default is False.\n\n    Returns:\n        None.\n    \"\"\"\n\n    # assign class variables\n    self.tidal = tidal\n    self.solver = solver\n    self.sol_pts = sol_pts\n    self.solve_ivp_kwargs = solve_ivp_kwargs  # this is only used in solve_ivp\n    self.tol = 1e-9  # this is only used in solve_ivp\n\n    # assign scaled variables\n    self.eps0 = 1.285e3  # MeV fm-3\n    self.pres0 = self.eps0\n    self.mass0 = 2.837  # solar masses\n    self.rad0 = 8.378  # km\n\n    # load in the data (expects file with data headers for now)\n    if eos_filepath is not None:\n\n        file_name, self.eos_file_extension = os.path.splitext(eos_filepath)\n        self.eos_name = (file_name.split(\"/\"))[-1]\n\n        # for data from compOSE\n        if self.eos_file_extension == \".table\":\n            # extract from .table file\n            self.eos_file = eos_filepath\n            eos_data = np.loadtxt(eos_filepath)\n\n            # check which column is which\n            if eos_data.T[4][-1] &lt; eos_data.T[3][-1]:\n                self.eps_array = eos_data.T[3] / self.eps0\n                self.pres_array = eos_data.T[4] / self.pres0\n            else:\n                self.eps_array = eos_data.T[4] / self.eps0\n                self.pres_array = eos_data.T[3] / self.pres0\n\n            self.nB_array = eos_data.T[1]\n\n            if tidal is True:\n                dpdeps = np.gradient(self.pres_array, self.eps_array, edge_order=2)\n                self.cs2_array = dpdeps\n            else:\n                self.cs2_array = np.zeros([len(self.pres_array)])\n\n            # keep unscaled for use in density calculation\n            self.pres_array_unscaled = eos_data.T[4]\n\n        # For data generated by codes\n        elif self.eos_file_extension == \".dat\" or self.eos_file_extension == \".txt\":\n\n            # extract data and assign to arrays (assumes one sample/draw of EOS)\n            self.eos_file = eos_filepath\n            print(\"Loading EOS data from file: \", eos_filepath)\n            eos_data = np.loadtxt(eos_filepath)  # , skiprows=2)\n            self.eps_array = eos_data.T[1] / self.eps0\n            self.pres_array = eos_data.T[2] / self.pres0\n            self.nB_array = eos_data.T[0]\n            if len(eos_data[1]) &gt; 3:\n                self.cs2_array = eos_data.T[3]\n            else:\n                self.cs2_array = None\n\n            # keep unscaled for use in density calculation\n            self.pres_array_unscaled = eos_data.T[2]\n\n        elif self.eos_file_extension == \".npz\":\n\n            self.eos_file = eos_filepath\n            eos_data = np.load(eos_filepath)\n\n            # assign to arrays based on header names\n            self.eps_array = eos_data[\"edens\"] / self.eps0\n            self.pres_array = eos_data[\"pres\"] / self.pres0\n            self.nB_array = eos_data[\"density\"]\n            self.cs2_array = eos_data[\"cs2\"]\n\n        # print congrats\n        print(\"Woo it worked!\")\n\n    else:\n        raise ValueError(\"No file specified.\")\n\n    return None\n</code></pre>"},{"location":"api/#slmemulator.TOV_class.TOV.RK4","title":"<code>RK4(f, x0, t0, te, N)</code>","text":"<p>A simple RK4 solver to avoid overhead of calculating with solve_ivp or any other adaptive step-size function.</p> Example <p>tov.RK4(f=func, x0=1., t0=1., te=10., N=100)</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>func</code> <p>A Python function for the ODE(s) to be solved. Able to solve N coupled ODEs.</p> required <code>x0</code> <code>float</code> <p>Guess for the function(s) to be solved.</p> required <code>t0</code> <code>float</code> <p>Initial point of the grid.</p> required <code>te</code> <code>float</code> <p>End point of the grid.</p> required <code>N</code> <code>int</code> <p>The number of steps to take in the range (te-t0).</p> required <p>Returns:</p> Name Type Description <code>times</code> <code>array</code> <p>The grid of solution steps.</p> <code>solution</code> <code>array</code> <p>The solutions of each function at each point in the grid.</p> Source code in <code>src/slmemulator/TOV_class.py</code> <pre><code>def RK4(self, f, x0, t0, te, N):\n    r\"\"\"\n    A simple RK4 solver to avoid overhead of\n    calculating with solve_ivp or any other\n    adaptive step-size function.\n\n    Example:\n        tov.RK4(f=func, x0=1., t0=1., te=10., N=100)\n\n    Parameters:\n        f (func): A Python function for the ODE(s) to be solved.\n            Able to solve N coupled ODEs.\n\n        x0 (float): Guess for the function(s) to be solved.\n\n        t0 (float): Initial point of the grid.\n\n        te (float): End point of the grid.\n\n        N (int): The number of steps to take in the range (te-t0).\n\n    Returns:\n        times (array): The grid of solution steps.\n\n        solution (array): The solutions of each function\n            at each point in the grid.\n    \"\"\"\n\n    h = (te - t0) / N\n    times = np.arange(t0, te + h, h)\n    solution = []\n    x = x0\n\n    for t in times:\n        solution.append(np.array(x).T)\n        k1 = h * f(t, x)\n        k2 = h * f(t + 0.5 * h, x + 0.5 * k1)\n        k3 = h * f(t + 0.5 * h, x + 0.5 * k2)\n        k4 = h * f(t + h, x + k3)\n        x += (k1 + 2 * (k2 + k3) + k4) / 6\n\n    solution = np.asarray(solution, dtype=np.float64).T\n\n    return times, solution\n</code></pre>"},{"location":"api/#slmemulator.TOV_class.TOV.RK2","title":"<code>RK2(f, x0, t0, te, N)</code>","text":"<p>A simple RK2 solver using the Heun's method. This is a low-fidelity solver.</p> Example <p>tov.RK2(f=func, x0=1., t0=1., te=10., N=100)</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>func</code> <p>A Python function for the ODE(s) to be solved. Able to solve N coupled ODEs.</p> required <code>x0</code> <code>float</code> <p>Guess for the function(s) to be solved.</p> required <code>t0</code> <code>float</code> <p>Initial point of the grid.</p> required <code>te</code> <code>float</code> <p>End point of the grid.</p> required <code>N</code> <code>int</code> <p>The number of steps to take in the range (te-t0).</p> required <p>Returns:</p> Name Type Description <code>times</code> <code>array</code> <p>The grid of solution steps.</p> <code>solution</code> <code>array</code> <p>The solutions of each function at each point in the grid.</p> Source code in <code>src/slmemulator/TOV_class.py</code> <pre><code>def RK2(self, f, x0, t0, te, N):\n    r\"\"\"\n    A simple RK2 solver using the Heun's method.\n    This is a low-fidelity solver.\n\n    Example:\n        tov.RK2(f=func, x0=1., t0=1., te=10., N=100)\n\n    Parameters:\n        f (func): A Python function for the ODE(s) to be solved.\n            Able to solve N coupled ODEs.\n\n        x0 (float): Guess for the function(s) to be solved.\n\n        t0 (float): Initial point of the grid.\n\n        te (float): End point of the grid.\n\n        N (int): The number of steps to take in the range (te-t0).\n\n    Returns:\n        times (array): The grid of solution steps.\n\n        solution (array): The solutions of each function\n            at each point in the grid.\n    \"\"\"\n\n    h = (te - t0) / N\n    times = np.arange(t0, te + h, h)\n    solution = []\n    x = x0\n\n    for t in times:\n        solution.append(np.array(x).T)\n        k1 = f(t, x)\n        k2 = f(t + h, x + k1 * h)\n        x += h * (k1 + k2) * 0.5\n\n    solution = np.asarray(solution, dtype=np.float64).T\n\n    return times, solution\n</code></pre>"},{"location":"api/#slmemulator.TOV_class.TOV.euler","title":"<code>euler(f, x0, t0, te, N)</code>","text":"<p>A simple forward euler solver to avoid overhead of calculating with solve_ivp or any other adaptive step-size function. This is a low fidelity solver!</p> Example <p>tov.euler(f=func, x0=1., t0=1., te=10., N=100)</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>func</code> <p>A Python function for the ODE(s) to be solved. Able to solve N coupled ODEs.</p> required <code>x0</code> <code>float</code> <p>Guess for the function(s) to be solved.</p> required <code>t0</code> <code>float</code> <p>Initial point of the grid.</p> required <code>te</code> <code>float</code> <p>End point of the grid.</p> required <code>N</code> <code>int</code> <p>The number of steps to take in the range (te-t0).</p> required <p>Returns:</p> Name Type Description <code>times</code> <code>array</code> <p>The grid of solution steps.</p> <code>solution</code> <code>array</code> <p>The solutions of each function at each point in the grid.</p> Source code in <code>src/slmemulator/TOV_class.py</code> <pre><code>def euler(self, f, x0, t0, te, N):\n    r\"\"\"\n    A simple forward euler solver to avoid overhead of\n    calculating with solve_ivp or any other\n    adaptive step-size function.\n    This is a low fidelity solver!\n\n    Example:\n        tov.euler(f=func, x0=1., t0=1., te=10., N=100)\n\n    Parameters:\n        f (func): A Python function for the ODE(s) to be solved.\n            Able to solve N coupled ODEs.\n\n        x0 (float): Guess for the function(s) to be solved.\n\n        t0 (float): Initial point of the grid.\n\n        te (float): End point of the grid.\n\n        N (int): The number of steps to take in the range (te-t0).\n\n    Returns:\n        times (array): The grid of solution steps.\n\n        solution (array): The solutions of each function\n            at each point in the grid.\n    \"\"\"\n\n    h = (te - t0) / N\n    times = np.arange(t0, te + h, h)\n    solution = []\n    x = x0\n\n    for t in times:\n        solution.append(np.array(x).T)\n        x += h * f(t, x)\n\n    solution = np.asarray(solution, dtype=np.float64).T\n\n    return times, solution\n</code></pre>"},{"location":"api/#slmemulator.TOV_class.TOV.tov_equations_scaled","title":"<code>tov_equations_scaled(x, y0)</code>","text":"<p>The Tolman-Oppenheimer-Volkoff equations in scaled format, to be solved with the RK4 routine. If selected, the tidal deformability and moment of inertia will be included and solved simultaneously.</p> Example <p>tov.tov_equations_scaled(x=0.2,     y0=[m_init, p_init])</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>A point in the scaled radius grid.</p> required <code>y0</code> <code>list</code> <p>The list of initial guesses for each function solved.</p> required <p>Returns:</p> Type Description <p>The solutions, in array format, of each function to be solved.</p> Source code in <code>src/slmemulator/TOV_class.py</code> <pre><code>def tov_equations_scaled(self, x, y0):\n    r\"\"\"\n    The Tolman-Oppenheimer-Volkoff equations in scaled format, to be\n    solved with the RK4 routine. If selected, the tidal deformability\n    and moment of inertia will be included and solved\n    simultaneously.\n\n    Example:\n        tov.tov_equations_scaled(x=0.2,\n            y0=[m_init, p_init])\n\n    Parameters:\n        x (float): A point in the scaled radius grid.\n\n        y0 (list): The list of initial guesses for each function\n            solved.\n\n    Returns:\n        The solutions, in array format, of each function to be\n            solved.\n    \"\"\"\n\n    # unpack the initial conditions\n    if self.tidal is True:\n        pres, mass, y = y0\n        cs2 = self.cs2_interp(pres)\n    else:\n        pres, mass = y0\n\n    eps = self.eps_interp(pres)\n\n    # must also receive monotonically increasing P(n) results\n    if pres &gt; 0.0:\n\n        # pressure equation\n        dpdx = (\n            -0.5 * (pres + eps) * (mass + 3 * x**3.0 * pres) / (x**2.0 - x * mass)\n        )\n\n        # mass equation\n        dmdx = 3.0 * x**2.0 * eps\n\n        # tidal deformability equation\n        if self.tidal is True:\n            f = self.f_x(x, mass, pres, eps)\n            q = self.q_x(x, mass, pres, eps, cs2)\n            dydx = -(1.0 / x) * (y**2.0 + f * y + q)\n\n    else:\n        dpdx = 0.0\n        dmdx = 0.0\n\n        if self.tidal is True:\n            dydx = 0.0\n\n    if self.tidal is True:\n        return np.array([dpdx, dmdx, dydx], dtype=np.float64)\n\n    return np.array([dpdx, dmdx], dtype=np.float64)\n</code></pre>"},{"location":"api/#slmemulator.TOV_class.TOV.f_x","title":"<code>f_x(x, mass, pres, eps)</code>","text":"<p>A function in the tidal deformability calculation.</p> Example <p>tov.f_x(x=0.2, mass=1.06, pres=2.34, eps=6.0)</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The current gridpoint in scaled radius.</p> required <code>mass</code> <code>float</code> <p>The current mass.</p> required <code>pres</code> <code>float</code> <p>The current pressure from the EOS.</p> required <code>eps</code> <code>float</code> <p>The current energy density from the EOS.</p> required <p>Returns:</p> Type Description <p>The value of F(x) at the current radius.</p> Source code in <code>src/slmemulator/TOV_class.py</code> <pre><code>def f_x(self, x, mass, pres, eps):\n    r\"\"\"\n    A function in the tidal deformability calculation.\n\n    Example:\n        tov.f_x(x=0.2, mass=1.06, pres=2.34, eps=6.0)\n\n    Parameters:\n        x (float): The current gridpoint in scaled radius.\n\n        mass (float): The current mass.\n\n        pres (float): The current pressure from the EOS.\n\n        eps (float): The current energy density from the EOS.\n\n    Returns:\n        The value of F(x) at the current radius.\n    \"\"\"\n\n    one = 1.0 - (3.0 / 2.0) * (eps - pres) * x**2.0\n    two = 1.0 - mass / x\n    return one / two\n</code></pre>"},{"location":"api/#slmemulator.TOV_class.TOV.q_x","title":"<code>q_x(x, mass, pres, eps, cs2)</code>","text":"<p>A function in the calculation of the tidal deformability.</p> Example <p>tov.q_x(x=0.1, mass=2.0, pres=1.0, eps=3.0, cs2=0.33)</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The current gridpoint in scaled radius.</p> required <code>mass</code> <code>float</code> <p>The current mass.</p> required <code>pres</code> <code>float</code> <p>The current pressure from the EOS.</p> required <code>eps</code> <code>float</code> <p>The current energy density from the EOS.</p> required <code>cs2</code> <code>float</code> <p>The current speed of sound from the EOS.</p> required <p>Returns:</p> Type Description <p>The value of Q(x) at the current radius.</p> Source code in <code>src/slmemulator/TOV_class.py</code> <pre><code>def q_x(self, x, mass, pres, eps, cs2):\n    r\"\"\"\n    A function in the calculation of the tidal deformability.\n\n    Example:\n        tov.q_x(x=0.1, mass=2.0, pres=1.0, eps=3.0, cs2=0.33)\n\n    Parameters:\n        x (float): The current gridpoint in scaled radius.\n\n        mass (float): The current mass.\n\n        pres (float): The current pressure from the EOS.\n\n        eps (float): The current energy density from the EOS.\n\n        cs2 (float): The current speed of sound from the EOS.\n\n    Returns:\n        The value of Q(x) at the current radius.\n    \"\"\"\n    pre = (3.0 / 2.0) * x**2.0 / (1.0 - mass / x)\n    one = 5.0 * eps + 9.0 * pres + ((eps + pres) / cs2) - (4.0 / x**2.0)\n    two = mass + 3.0 * x**3.0 * pres\n    three = x - mass\n    return pre * one - (two / three) ** 2.0\n</code></pre>"},{"location":"api/#slmemulator.TOV_class.TOV.tidal_def","title":"<code>tidal_def(yR, mass, radius)</code>","text":"<p>The calculation of the tidal deformability, Lambda, and the tidal Love number, k2. This function is calculated after the RK4 routine has been completed.</p> Example <p>tov.tidal_def(yR=np.array, mass=np.array, radius=np.array)</p> <p>Parameters:</p> Name Type Description Default <code>yR</code> <code>float</code> <p>The array of y at the maximum radii points.</p> required <code>mass</code> <code>float</code> <p>The array of mass at the maximum radii.</p> required <code>radius</code> <code>float</code> <p>The maximum radii array.</p> required <p>Returns:</p> Name Type Description <code>tidal_deform</code> <code>array</code> <p>The tidal deformability solved at each point in the maximum radius.</p> <code>k2</code> <code>array</code> <p>The value of the Love number calculated at the compactness M/R and the value of y at maximum radius.</p> Source code in <code>src/slmemulator/TOV_class.py</code> <pre><code>def tidal_def(self, yR, mass, radius):\n    r\"\"\"\n    The calculation of the tidal deformability, Lambda, and\n    the tidal Love number, k2. This function is calculated after\n    the RK4 routine has been completed.\n\n    Example:\n        tov.tidal_def(yR=np.array, mass=np.array, radius=np.array)\n\n    Parameters:\n        yR (float): The array of y at the maximum radii points.\n\n        mass (float): The array of mass at the maximum radii.\n\n        radius (float): The maximum radii array.\n\n    Returns:\n        tidal_deform (array): The tidal deformability solved at\n            each point in the maximum radius.\n\n        k2 (array): The value of the Love number calculated at the\n            compactness M/R and the value of y at maximum radius.\n    \"\"\"\n\n    # love number calculation\n    beta = (mass / radius) * (self.rad0 / (2.0 * self.mass0))\n    k2 = (\n        (8.0 / 5.0)\n        * beta**5.0\n        * (1.0 - 2.0 * beta) ** 2.0\n        * (2.0 - yR + 2.0 * beta * (yR - 1.0))\n        * (\n            2.0 * beta * (6.0 - 3.0 * yR + 3.0 * beta * (5.0 * yR - 8.0))\n            + 4.0\n            * beta**3.0\n            * (\n                13.0\n                - 11.0 * yR\n                + beta * (3.0 * yR - 2.0)\n                + 2.0 * beta**2.0 * (1.0 + yR)\n            )\n            + 3.0\n            * (1.0 - 2.0 * beta) ** 2.0\n            * (2.0 - yR + 2.0 * beta * (yR - 1.0))\n            * np.log(1.0 - 2.0 * beta)\n        )\n        ** (-1.0)\n    )\n\n    # tidal deformability calculation\n    tidal_deform = (\n        (2.0 / 3.0) * k2 * (2.0 * self.mass0 * radius / (self.rad0 * mass)) ** 5.0\n    )\n\n    return tidal_deform, k2\n</code></pre>"},{"location":"api/#slmemulator.TOV_class.TOV.tov_routine","title":"<code>tov_routine(verbose=False, write_to_file=False)</code>","text":"<p>The TOV routine to solve each set of coupled ODEs and to output the quantities needed to display the M-R curve, as well as the tidal deformability and moment of inertia if desired.</p> Example <p>tov.tov_routine(verbose=True, write_to_file=True)</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>Whether to plot quantities and display the full maximum mass array. Default is False.</p> <code>False</code> <code>write_to_file</code> <code>bool</code> <p>Choice to write the TOV results to a file located in a folder of the user's choice. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <p>self.total_radius (array): The array of total maximum radius values.</p> <p>self.total_pres_central (array): The array of total central pressure values.</p> <p>self.total_max_mass (array): The array of total maximum mass values.</p> Source code in <code>src/slmemulator/TOV_class.py</code> <pre><code>def tov_routine(self, verbose=False, write_to_file=False):\n    r\"\"\"\n    The TOV routine to solve each set of coupled ODEs and to output\n    the quantities needed to display the M-R curve, as well as the\n    tidal deformability and moment of inertia if desired.\n\n    Example:\n        tov.tov_routine(verbose=True, write_to_file=True)\n\n    Parameters:\n        verbose (bool): Whether to plot quantities and display\n            the full maximum mass array. Default is False.\n\n        write_to_file (bool): Choice to write the TOV results to\n            a file located in a folder of the user's choice.\n            Default is False.\n\n    Returns:\n        self.total_radius (array): The array of total maximum\n            radius values.\n\n        self.total_pres_central (array): The array of total\n            central pressure values.\n\n        self.total_max_mass (array): The array of total\n            maximum mass values.\n    \"\"\"\n    # list for storing results\n    self.sols_varying_p0 = []\n    # initial pressure\n    pres_init = min(2.0, np.max(self.pres_array))  # Use np.max for clarity\n    mass_init = 0.0\n\n    if self.tidal is True:\n        y_init = 2.0\n\n    # set initial radius array\n    low_pres = max(1e-3, np.min(self.pres_array))  # Use np.min for clarity\n    x = np.geomspace(1e-8, 2.5, 50)\n    pres_space = np.geomspace(low_pres, pres_init, len(x))\n    self.pres_space = pres_space\n\n    if self.tidal is True:\n        self.yR = np.zeros(len(x))\n\n    # set up arrays for the final results\n    self.total_mass = np.zeros(len(x))\n    self.total_radius = np.zeros(len(x))\n    self.total_pres_central = np.zeros(len(x))\n\n    # set up arrays (impermanent so this will work)\n    max_mass = np.zeros(len(x))\n    pres_central = np.zeros(len(x))\n    max_radius = np.zeros(len(x))\n\n    # interpolate the energy density\n    self.eps_interp = interp1d(\n        self.pres_array,\n        self.eps_array,\n        axis=0,\n        kind=\"linear\",\n        fill_value=\"extrapolate\",\n    )\n\n    if self.tidal is True:\n        self.cs2_interp = interp1d(\n            self.pres_array,\n            self.cs2_array,\n            axis=0,\n            kind=\"linear\",\n            fill_value=\"extrapolate\",\n        )\n\n    # loop over the TOV equations\n    for i in range(len(x)):\n        init_guess = []\n        # initial conditions\n        mass_arg = mass_init\n        pres_arg = pres_space[i]\n        init_guess.append(pres_arg)\n        init_guess.append(mass_arg)\n\n        if self.tidal is True:\n            y_arg = y_init\n            init_guess.append(y_arg)\n\n        # Improve init_guess as one entry for all solutions\n        # high fidelity (four function evals per sol_pt)\n        if self.solver == \"RK4\":\n            xval, sol = self.RK4(\n                self.tov_equations_scaled, init_guess, 1e-3, 4.0, self.sol_pts\n            )\n\n        # low fidelity (two function evals per sol_pt)\n        elif self.solver == \"RK2\":\n            xval, sol = self.RK2(\n                self.tov_equations_scaled, init_guess, 1e-3, 4.0, self.sol_pts\n            )\n\n        # low fidelity (one function eval per sol_pt)\n        elif self.solver == \"euler\":\n            xval, sol = self.euler(\n                self.tov_equations_scaled, init_guess, 1e-3, 4.0, self.sol_pts\n            )\n\n        # adaptive (typically high fidelity)\n        elif self.solver == \"solve_ivp\":\n            if self.solve_ivp_kwargs is None:\n                self.solve_ivp_kwargs = {\n                    \"method\": \"RK45\",\n                    \"atol\": 5e-14,\n                    \"rtol\": self.tol,\n                    \"max_step\": 0.01,\n                    \"dense_output\": True,\n                }\n            if self.tidal is True:\n                sol = solve_ivp(\n                    self.tov_equations_scaled,\n                    [1e-3, 2.5],\n                    [pres_arg, mass_arg, y_arg],\n                    **self.solve_ivp_kwargs,\n                )\n            else:\n                sol = solve_ivp(\n                    self.tov_equations_scaled,\n                    [1e-8, 2.5],\n                    [pres_arg, mass_arg],\n                    **self.solve_ivp_kwargs,\n                )\n            if not sol.success:\n                print(\"Solver failed.\")\n                print(sol.message)\n            xval = sol.t\n            sol = sol.y\n        else:\n            raise ValueError(\n                f'Solver, {self.solver} unknown. Must be \"RK4\", \"RK2\", \"euler\", or \"solve_ivp\".'\n            )\n\n        # maximum mass\n        # Find the index where pressure becomes very small (approaching zero)\n        # Use np.flatnonzero for more robust indexing\n        pressure_positive_indices = np.flatnonzero(sol[0] &gt; 1e-10)\n        if pressure_positive_indices.size &gt; 0:\n            index_mass = pressure_positive_indices[-1]\n            max_mass[i] = sol[1, index_mass]\n        else:\n            # Handle cases where pressure never goes above threshold or immediately drops\n            max_mass[i] = 0.0  # Or some other appropriate default\n            # print(f\"Warning: Pressure did not stay positive for central pressure {pres_arg}\")\n\n        # central pressure\n        pres_central[i] = np.max(sol[0])\n\n        # maximum radius\n        max_radius[i] = xval[index_mass]\n\n        if self.tidal is True:\n            self.yR[i] = sol[2][index_mass]\n\n        # Collect the results for each central pressure\n        solns = np.column_stack(\n            [\n                xval[: index_mass + 1] * self.rad0,  # radius\n                sol[0][: index_mass + 1] * self.pres0,  # pressure\n                sol[1][: index_mass + 1] * self.mass0,  # mass\n                sol[2][: index_mass + 1] if self.tidal else None,\n            ],\n        )\n        self.sols_varying_p0.append(solns.T)\n\n    # scale results (send back totals at the end using these)\n    max_mass = max_mass * self.mass0\n    max_radius = max_radius * self.rad0\n    pres_central = pres_central * self.pres0\n    self.total_mass = max_mass\n    self.total_radius = max_radius\n    self.total_pres_central = pres_central\n    # max mass calculation, radius, and central pressure\n    self.maximum_mass = np.max(max_mass)\n    corr_radius_index = np.where(max_mass == self.maximum_mass)[0][0]\n    self.corr_radius = max_radius[corr_radius_index]\n    self.corr_pres = pres_central[corr_radius_index]\n\n    # save these results\n    self.max_mass_arr = self.maximum_mass\n    self.max_radius_arr = self.corr_radius\n    self.max_pres_arr = self.corr_pres\n\n    print(\n        \"Max mass: \",\n        self.maximum_mass,\n        \"Radius: \",\n        self.corr_radius,\n        \"Central pressure: \",\n        self.corr_pres,\n    )\n\n    # tidal deformability\n    if self.tidal is True:\n        self.tidal_deformability, self.k2 = self.tidal_def(\n            self.yR, max_mass, max_radius\n        )\n        # print(\n        # \"Tidal deformability at all points: {}\".format(self.tidal_deformability)\n        # )\n        # print(\"k2 at all points: {}\".format(self.k2))\n\n    if verbose is True:\n        print(\"Max mass array: \", max_mass)\n\n        # plot stuff\n        plt.plot(max_radius, max_mass, label=r\"TOV\")\n        # plt.plot(dense_rad, mrad_arr, label=r'Interpolant')\n        plt.xlabel(\"Radius [km]\")\n        plt.ylabel(\"Max Mass [M_solar]\")\n        plt.legend()\n        plt.show()\n        plt.plot(max_radius, pres_central)\n        plt.xlabel(\"Radius [km]\")\n        plt.ylabel(\"Central pressure [MeV/fm^3]\")\n        plt.show()\n\n        if self.tidal is True:\n            plt.plot(max_mass / max_radius, self.yR)\n            plt.xlabel(r\"$\\beta$\")\n            plt.ylabel(r\"y(r)\")\n            plt.savefig(\"yr_scaled.png\")\n            plt.show()\n            # fig = plt.figure(figsize=(8,6), dpi=200)\n            plt.plot(max_radius, self.tidal_deformability, color=\"k\")\n            plt.xlabel(\"Radius\", fontsize=14)\n            plt.ylabel(r\"$\\Lambda(R)$\", fontsize=14)\n            plt.xticks(fontsize=12)\n            plt.yticks(fontsize=12)\n            plt.savefig(\"tidal.png\")\n            plt.show()\n            # fig = plt.figure(figsize=(8,6), dpi=200)\n            plt.plot(max_mass, self.tidal_deformability, color=\"k\")\n            plt.xlabel(r\"Mass [$M_{\\odot}$]\", fontsize=14)\n            plt.ylabel(r\"$\\Lambda(M)$\", fontsize=14)\n            plt.xticks(fontsize=12)\n            plt.yticks(fontsize=12)\n            plt.savefig(\"tidal_mass.png\")\n            plt.show()\n            # fig = plt.figure(figsize=(8,6), dpi=200)\n            plt.plot(max_mass / max_radius, self.k2, color=\"k\")\n            plt.xticks(fontsize=12)\n            plt.yticks(fontsize=12)\n            plt.xlabel(r\"$\\beta$\", fontsize=14)\n            plt.ylabel(r\"$k_{2}(\\beta)$\", fontsize=14)\n            plt.savefig(\"k2.png\")\n            plt.show()\n            # fig = plt.figure(figsize=(8,6), dpi=200)\n            plt.plot(max_radius, self.k2, color=\"k\")\n            plt.xticks(fontsize=12)\n            plt.yticks(fontsize=12)\n            plt.xlabel(r\"$R$ [km]\", fontsize=14)\n            plt.ylabel(r\"$k_{2}(R)$\", fontsize=14)\n            plt.xlim(9.0, 15.0)\n            plt.savefig(\"k2R.png\")\n            plt.show()\n\n        # check the solution\n        print(\n            \"Radius: \",\n            self.corr_radius,\n            \"Maximum mass: \",\n            self.maximum_mass,\n            \"Central pressure: \",\n            self.corr_pres,\n        )\n\n    # if desired, write to a file\n    if write_to_file is True:\n        tov_data = np.column_stack(\n            [self.total_radius, self.total_mass, self.total_pres_central]\n        )\n        file_name = \"TOV_data/rpm_results\" + \"_\" + self.eos_name + \".txt\"\n        header = \"Radius[km] Mass[Msol] Central_Pressure[MeV/fm3]\"\n        np.savetxt(file_name, tov_data, header=header, delimiter=\" \")\n\n    if self.tidal is True:\n        return (\n            self.total_radius,\n            self.total_pres_central,\n            self.total_mass,\n            self.k2,\n            self.tidal_deformability,\n        )\n    return self.total_radius, self.total_pres_central, self.total_mass\n</code></pre>"},{"location":"api/#slmemulator.TOV_class.TOV.max_arrays","title":"<code>max_arrays()</code>","text":"<p>Returns the max arrays needed for the interval calculation.</p> <p>Returns:</p> Type Description <p>self.max_radius_arr (array): Maximum radius array.</p> <p>self.max_pres_arr (array): Maximum central pressure array.</p> <p>self.max_mass_arr (array): Maximum mass array.</p> Source code in <code>src/slmemulator/TOV_class.py</code> <pre><code>def max_arrays(self):\n    r\"\"\"\n    Returns the max arrays needed for the interval calculation.\n\n    Parameters:\n        None.\n\n    Returns:\n        self.max_radius_arr (array): Maximum radius array.\n        self.max_pres_arr (array): Maximum central pressure array.\n        self.max_mass_arr (array): Maximum mass array.\n    \"\"\"\n    return self.max_radius_arr, self.max_pres_arr, self.max_mass_arr\n</code></pre>"},{"location":"api/#slmemulator.TOV_class.TOV.central_dens","title":"<code>central_dens(pres_arr=None)</code>","text":"<p>Calculation to determine the central density of the star at the maximum mass and radius determined from the tov_routine().</p> Example <p>tov.central_dens()</p> <p>Parameters:</p> Name Type Description Default <code>pres_arr</code> <code>array</code> <p>An optional pressure array to use for calculating central densities at places other than the absolute TOV maximum mass of each curve. Default is None, and code will use absolute TOV maximum mass central pressure class array.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>c_dens</code> <code>array</code> <p>The array of central densities for each EOS used.</p> Source code in <code>src/slmemulator/TOV_class.py</code> <pre><code>def central_dens(self, pres_arr=None):\n    r\"\"\"\n    Calculation to determine the central density of the star\n    at the maximum mass and radius determined from the tov_routine().\n\n    Example:\n        tov.central_dens()\n\n    Parameters:\n        pres_arr (array): An optional pressure array to use for\n            calculating central densities at places other\n            than the absolute TOV maximum mass of each curve.\n            Default is None, and code will use absolute TOV\n            maximum mass central pressure class array.\n\n    Returns:\n        c_dens (array): The array of central densities for\n            each EOS used.\n    \"\"\"\n\n    # interpolate the EOS to find the proper central densities\n    p_n_interp = interp1d(\n        self.pres_array_unscaled,\n        self.nB_array,\n        kind=\"cubic\",\n        fill_value=\"extrapolate\",\n    )\n\n    # solve at the proper central pressure for nB_central\n    c_dens = p_n_interp(self.corr_pres)\n\n    return c_dens\n</code></pre>"},{"location":"api/#slmemulator.TOV_class.TOV.canonical_NS_radius","title":"<code>canonical_NS_radius()</code>","text":"<p>Calculation of the radius of a 1.4 M_sol neutron star.</p> Example <p>tov.canonical_NS_radius()</p> <p>Returns:</p> Name Type Description <code>rad_14</code> <code>array</code> <p>The array of values of the radius for each EOS used.</p> Source code in <code>src/slmemulator/TOV_class.py</code> <pre><code>def canonical_NS_radius(self):\n    r\"\"\"\n    Calculation of the radius of a 1.4 M_sol neutron star.\n\n    Example:\n        tov.canonical_NS_radius()\n\n    Parameters:\n        None.\n\n    Returns:\n        rad_14 (array): The array of values of the radius\n            for each EOS used.\n    \"\"\"\n\n    # interpolate the mass radius result?\n    m_r_interp = interp1d(\n        self.total_mass,\n        self.total_radius,\n        kind=\"linear\",\n        fill_value=\"extrapolate\",\n    )\n    return m_r_interp(1.4)\n</code></pre>"},{"location":"api/#slmemulator.tovScaledRev","title":"<code>tovScaledRev</code>","text":"<p>Information about the code: This code solves TOV equations for mass radius relations. This can also plot the mass-radius curve.</p> <p>The code solves dr/dp and dm/dp instead of the regular way.</p> <p>USE: To use the code, here are the steps: 1) Include the file in your main code e.g. import tov_class as tc 2) Load the EoS using the ToV loader, tc.ToV(filename, arraysize) 3) call the solver as tc.ToV.mass_radius(min_pressure, max_pressure) 4) To plot, follow the code in main() on creating the dictionary of inputs</p> <p>Updates: Version 0.0.1-1 Solves ToV, can only take inputs of pressure (MeV/fm^3), energy density in MeV, baryon density in fm^-3 in ascending order.</p>"},{"location":"api/#slmemulator.tovScaledRev.TOV","title":"<code>TOV(filename, imax, tidal=False)</code>","text":"<p>Solves TOV equations and gives data-table, mass-radius plot and max. mass, central pressure and central density by loading an EoS datafile.</p> Source code in <code>src/slmemulator/tovScaledRev.py</code> <pre><code>def __init__(self, filename, imax, tidal=False):\n    self.file = np.loadtxt(filename)\n    self.tidal = tidal\n    self.e_in = self.file[:, 1] / eps0  # Scaled Energy density\n    self.p_in = self.file[:, 2] / pres0  # Scaled pressure\n    self.nb_in = self.file[:, 0]  # Scaled baryon density\n    if self.tidal:\n        self.cs2_in = self.file[:, 3]  # sound speed\n    self.imax = imax\n    self.radius = np.empty(self.imax)\n    self.mass = np.empty(self.imax)\n</code></pre>"},{"location":"api/#slmemulator.tovScaledRev.TOV.pressure_from_nb","title":"<code>pressure_from_nb(nb)</code>","text":"<p>Evaluate pressure from number density using interpolation</p> Source code in <code>src/slmemulator/tovScaledRev.py</code> <pre><code>def pressure_from_nb(self, nb):\n    \"\"\"Evaluate pressure from number density using interpolation\"\"\"\n    p1 = interp1d(\n        self.nb_in, self.p_in, axis=0, kind=\"linear\", fill_value=\"extrapolate\"\n    )\n    return p1(nb)\n</code></pre>"},{"location":"api/#slmemulator.tovScaledRev.TOV.energy_from_pressure","title":"<code>energy_from_pressure(pressure)</code>","text":"<p>Evaluate energy density from pressure using interpolation</p> Source code in <code>src/slmemulator/tovScaledRev.py</code> <pre><code>def energy_from_pressure(self, pressure):\n    \"\"\"Evaluate energy density from pressure using interpolation\"\"\"\n    plow = 1e-10 / pres0\n    if pressure &lt; plow:\n        return 2.6e-310\n    else:\n        e1 = interp1d(\n            self.p_in, self.e_in, axis=0, kind=\"linear\", fill_value=\"extrapolate\"\n        )\n        return e1(pressure)\n</code></pre>"},{"location":"api/#slmemulator.tovScaledRev.TOV.pressure_from_energy","title":"<code>pressure_from_energy(energy)</code>","text":"<p>Evaluate pressure from energy density using interpolation</p> Source code in <code>src/slmemulator/tovScaledRev.py</code> <pre><code>def pressure_from_energy(self, energy):\n    \"\"\"Evaluate pressure from energy density using interpolation\"\"\"\n    p1 = interp1d(\n        self.e_in, self.p_in, axis=0, kind=\"linear\", fill_value=\"extrapolate\"\n    )\n    return p1(energy)\n</code></pre>"},{"location":"api/#slmemulator.tovScaledRev.TOV.baryon_from_energy","title":"<code>baryon_from_energy(energy)</code>","text":"<p>Evaluate number density from energy using interpolation</p> Source code in <code>src/slmemulator/tovScaledRev.py</code> <pre><code>def baryon_from_energy(self, energy):\n    \"\"\"Evaluate number density from energy using interpolation\"\"\"\n    n1 = interp1d(\n        self.e_in, self.nb_in, axis=0, kind=\"linear\", fill_value=\"extrapolate\"\n    )\n    return n1(energy)\n</code></pre>"},{"location":"authors/","title":"Authors","text":""},{"location":"authors/#sudhanva-lalit-alexandra-semposki-joshua-maldonado","title":"Sudhanva Lalit, Alexandra Semposki, Joshua Maldonado","text":""},{"location":"changelog/","title":"Changelog","text":""},{"location":"contributing/","title":"Contributing","text":"<p>To help contribute to the project, please submit suggestions via the Issues tab on GitHub.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#using-pypi","title":"Using pypi","text":"<p>You can install <code>slm</code> using pip:</p> <pre><code>pip install slm\n</code></pre>"},{"location":"installation/#using-github","title":"Using github","text":"<p>Alternatively you can also download the package from the github repository and install using:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"usage/","title":"Testing with this file.","text":""},{"location":"tutorials/Parametric_SLM/","title":"Parametric SLM","text":"<pre><code># import relevant packages\nimport numpy as np \nimport matplotlib.pyplot as plt\n\n# install the package from source\n# SLM goes here\n</code></pre>"},{"location":"tutorials/Parametric_SLM/#parametric-star-log-extended-emulation","title":"Parametric Star Log-extended eMulation","text":""},{"location":"tutorials/Parametric_SLM/#authors-sudhanva-lalit-alexandra-c-semposki-joshua-m-maldonado","title":"Authors: Sudhanva Lalit, Alexandra C. Semposki, Joshua M. Maldonado","text":""},{"location":"tutorials/Parametric_SLM/#date-last-edited-30-october-2024","title":"Date last edited: 30 October 2024","text":"<p>In this notebook, we will demonstrate the use of the parametric component of our <code>SLM</code> package on the 2-parameter quarkyonic EOS. We will then compare to the high-fidelity solutions calculated using the standard RK4 method. This notebooks reproduces Fig. 3 from our accompanying paper.</p>"},{"location":"tutorials/SLM_general/","title":"SLM General","text":"<pre><code># import packages\n#[include autoreload here]\n\nimport numpy as np \nfrom scipy.interpolate import interp1d \nimport matplotlib.pyplot as plt\n\n# install the SLM package from source (potentially)\n# \n</code></pre>"},{"location":"tutorials/SLM_general/#star-log-extended-emulation-a-general-overview","title":"Star Log-extended eMulation: a general overview","text":""},{"location":"tutorials/SLM_general/#authors-sudhanva-lalit-alexandra-c-semposki-joshua-m-maldonado","title":"Authors: Sudhanva Lalit, Alexandra C. Semposki, Joshua M. Maldonado","text":""},{"location":"tutorials/SLM_general/#date-last-edited-30-october-2024","title":"Date last edited: 30 October 2024","text":"<p>In this tutorial notebook, we outline the use of our package <code>SLM</code> and show its power using the Sly4 equation of state (EOS). This notebook reproduces Figs. 1 and 2 in our accompanying paper.</p>"},{"location":"tutorials/TOV_code/","title":"TOV Code","text":"<pre><code># import the relevant packages\nimport numpy as np \nimport matplotlib.pyplot as plt \n\n# import the slmemulator package\nfrom slmemulator import TOV\n</code></pre> <pre><code># run the help function to see what the TOVsolver does\nhelp(TOV)\n</code></pre> <pre>\n<code>Help on class TOV in module slmemulator.TOV_class:\n\nclass TOV(builtins.object)\n |  TOV(\n |      eos_filepath=None,\n |      tidal=False,\n |      solver='RK4',\n |      solve_ivp_kwargs=None,\n |      sol_pts=4000\n |  )\n |\n |  Methods defined here:\n |\n |  RK2(self, f, x0, t0, te, N)\n |      A simple RK2 solver using the Heun's method.\n |      This is a low-fidelity solver.\n |\n |      Example:\n |          tov.RK2(f=func, x0=1., t0=1., te=10., N=100)\n |\n |      Parameters:\n |          f (func): A Python function for the ODE(s) to be solved.\n |              Able to solve N coupled ODEs.\n |\n |          x0 (float): Guess for the function(s) to be solved.\n |\n |          t0 (float): Initial point of the grid.\n |\n |          te (float): End point of the grid.\n |\n |          N (int): The number of steps to take in the range (te-t0).\n |\n |      Returns:\n |          times (array): The grid of solution steps.\n |\n |          solution (array): The solutions of each function\n |              at each point in the grid.\n |\n |  RK4(self, f, x0, t0, te, N)\n |      A simple RK4 solver to avoid overhead of\n |      calculating with solve_ivp or any other\n |      adaptive step-size function.\n |\n |      Example:\n |          tov.RK4(f=func, x0=1., t0=1., te=10., N=100)\n |\n |      Parameters:\n |          f (func): A Python function for the ODE(s) to be solved.\n |              Able to solve N coupled ODEs.\n |\n |          x0 (float): Guess for the function(s) to be solved.\n |\n |          t0 (float): Initial point of the grid.\n |\n |          te (float): End point of the grid.\n |\n |          N (int): The number of steps to take in the range (te-t0).\n |\n |      Returns:\n |          times (array): The grid of solution steps.\n |\n |          solution (array): The solutions of each function\n |              at each point in the grid.\n |\n |  __init__(\n |      self,\n |      eos_filepath=None,\n |      tidal=False,\n |      solver='RK4',\n |      solve_ivp_kwargs=None,\n |      sol_pts=4000\n |  )\n |      Class to calculate the Tolman-Oppenheimer-Volkoff equations,\n |      including options for the tidal deformability and moment of\n |      inertia using RK4. Also includes uncertainty quantification\n |      techniques through the highest posterior density interval (HPD\n |      or HDI) calculation. Able to accept one EOS from a single curve\n |      or draws from an EOS, such as from a Gaussian Process.\n |\n |      Example:\n |          tov = TOVSolver(eos_filepath='path/to/eos', tidal=True, moment=True)\n |\n |      Parameters:\n |          eos_filepath (str): The path to the EOS data table to be used.\n |\n |          tidal (bool): Whether to calculate tidal deformability or not.\n |              Default is False.\n |\n |          moment (bool): Whether to calculate moment of inertia or not.\n |              Default is False.\n |\n |      Returns:\n |          None.\n |\n |  canonical_NS_radius(self)\n |      Calculation of the radius of a 1.4 M_sol neutron star.\n |\n |      Example:\n |          tov.canonical_NS_radius()\n |\n |      Parameters:\n |          None.\n |\n |      Returns:\n |          rad_14 (array): The array of values of the radius\n |              for each EOS used.\n |\n |  central_dens(self, pres_arr=None)\n |      Calculation to determine the central density of the star\n |      at the maximum mass and radius determined from the tov_routine().\n |\n |      Example:\n |          tov.central_dens()\n |\n |      Parameters:\n |          pres_arr (array): An optional pressure array to use for\n |              calculating central densities at places other\n |              than the absolute TOV maximum mass of each curve.\n |              Default is None, and code will use absolute TOV\n |              maximum mass central pressure class array.\n |\n |      Returns:\n |          c_dens (array): The array of central densities for\n |              each EOS used.\n |\n |  euler(self, f, x0, t0, te, N)\n |      A simple forward euler solver to avoid overhead of\n |      calculating with solve_ivp or any other\n |      adaptive step-size function.\n |      This is a low fidelity solver!\n |\n |      Example:\n |          tov.euler(f=func, x0=1., t0=1., te=10., N=100)\n |\n |      Parameters:\n |          f (func): A Python function for the ODE(s) to be solved.\n |              Able to solve N coupled ODEs.\n |\n |          x0 (float): Guess for the function(s) to be solved.\n |\n |          t0 (float): Initial point of the grid.\n |\n |          te (float): End point of the grid.\n |\n |          N (int): The number of steps to take in the range (te-t0).\n |\n |      Returns:\n |          times (array): The grid of solution steps.\n |\n |          solution (array): The solutions of each function\n |              at each point in the grid.\n |\n |  f_x(self, x, mass, pres, eps)\n |      A function in the tidal deformability calculation.\n |\n |      Example:\n |          tov.f_x(x=0.2, mass=1.06, pres=2.34, eps=6.0)\n |\n |      Parameters:\n |          x (float): The current gridpoint in scaled radius.\n |\n |          mass (float): The current mass.\n |\n |          pres (float): The current pressure from the EOS.\n |\n |          eps (float): The current energy density from the EOS.\n |\n |      Returns:\n |          The value of F(x) at the current radius.\n |\n |  max_arrays(self)\n |      Returns the max arrays needed for the interval calculation.\n |\n |      Parameters:\n |          None.\n |\n |      Returns:\n |          self.max_radius_arr (array): Maximum radius array.\n |          self.max_pres_arr (array): Maximum central pressure array.\n |          self.max_mass_arr (array): Maximum mass array.\n |\n |  q_x(self, x, mass, pres, eps, cs2)\n |      A function in the calculation of the tidal deformability.\n |\n |      Example:\n |          tov.q_x(x=0.1, mass=2.0, pres=1.0, eps=3.0, cs2=0.33)\n |\n |      Parameters:\n |          x (float): The current gridpoint in scaled radius.\n |\n |          mass (float): The current mass.\n |\n |          pres (float): The current pressure from the EOS.\n |\n |          eps (float): The current energy density from the EOS.\n |\n |          cs2 (float): The current speed of sound from the EOS.\n |\n |      Returns:\n |          The value of Q(x) at the current radius.\n |\n |  tidal_def(self, yR, mass, radius)\n |      The calculation of the tidal deformability, Lambda, and\n |      the tidal Love number, k2. This function is calculated after\n |      the RK4 routine has been completed.\n |\n |      Example:\n |          tov.tidal_def(yR=np.array, mass=np.array, radius=np.array)\n |\n |      Parameters:\n |          yR (float): The array of y at the maximum radii points.\n |\n |          mass (float): The array of mass at the maximum radii.\n |\n |          radius (float): The maximum radii array.\n |\n |      Returns:\n |          tidal_deform (array): The tidal deformability solved at\n |              each point in the maximum radius.\n |\n |          k2 (array): The value of the Love number calculated at the\n |              compactness M/R and the value of y at maximum radius.\n |\n |  tov_equations_scaled(self, x, y0)\n |      The Tolman-Oppenheimer-Volkoff equations in scaled format, to be\n |      solved with the RK4 routine. If selected, the tidal deformability\n |      and moment of inertia will be included and solved\n |      simultaneously.\n |\n |      Example:\n |          tov.tov_equations_scaled(x=0.2,\n |              y0=[m_init, p_init])\n |\n |      Parameters:\n |          x (float): A point in the scaled radius grid.\n |\n |          y0 (list): The list of initial guesses for each function\n |              solved.\n |\n |      Returns:\n |          The solutions, in array format, of each function to be\n |              solved.\n |\n |  tov_routine(self, verbose=False, write_to_file=False)\n |      The TOV routine to solve each set of coupled ODEs and to output\n |      the quantities needed to display the M-R curve, as well as the\n |      tidal deformability and moment of inertia if desired.\n |\n |      Example:\n |          tov.tov_routine(verbose=True, write_to_file=True)\n |\n |      Parameters:\n |          verbose (bool): Whether to plot quantities and display\n |              the full maximum mass array. Default is False.\n |\n |          write_to_file (bool): Choice to write the TOV results to\n |              a file located in a folder of the user's choice.\n |              Default is False.\n |\n |      Returns:\n |          self.total_radius (array): The array of total maximum\n |              radius values.\n |\n |          self.total_pres_central (array): The array of total\n |              central pressure values.\n |\n |          self.total_max_mass (array): The array of total\n |              maximum mass values.\n |\n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |\n |  __dict__\n |      dictionary for instance variables\n |\n |  __weakref__\n |      list of weak references to the object\n\n</code>\n</pre> <p>As you can see above, this class has multiple high-fidelity solvers implemented. The best one (so far) is the RK4 solver. You can supply the name of it in the <code>solver</code> argument of the class.</p> <pre><code>from slmemulator.config import get_paths\npaths = get_paths()\neos_data_dir = paths['eos_data_dir']\n\n# Create an instance of the TOV solver\ntov = TOV(eos_data_dir / 'apr_eos.table',tidal=True)\nresults = tov.tov_routine()\n# plot the results\nplt.figure(figsize=(10, 6))\nplt.plot(results[0], results[2], label='HF')\nplt.xlabel('Radius (km)')\nplt.ylabel('Mass (M_sun)')\nplt.title('TOV Solution')\nplt.legend()\n# plt.grid()\nplt.show()\n</code></pre> <pre>\n<code>Woo it worked!\nMax mass:  2.192818228236291 Radius:  9.967329639499997 Central pressure:  1032.2286804996406\n</code>\n</pre> <pre><code># plot the results\nplt.figure(figsize=(10, 6))\nplt.plot(results[0], results[3], label='HF')\nplt.xlabel('Radius (km)')\nplt.ylabel(r'$k_2$')\nplt.title('TOV Solution')\nplt.legend()\n# plt.grid()\nplt.show()\n</code></pre> <pre><code>from slmemulator.config import get_paths\nimport os\npaths = get_paths()\neos_data_dir = paths['eos_data_dir']\nos.listdir(eos_data_dir)\n</code></pre> <pre>\n<code>['BFH_eos.table',\n 'BL_eos.table',\n 'DS_CMF_eos.table',\n 'EOS_Quarkyonia.dat',\n 'FSUGarnetNStarEOSA.txt',\n 'Gibbs_EOS.dat',\n 'Gibbs_MS_Bag_MFT.dat',\n 'MFT_ns6p.dat',\n 'MS_EOS.dat',\n 'MS_fullEOS.dat',\n 'Max_EOS.dat',\n 'NJL_EOS.dat',\n 'Polytrope_1.0_gamma.dat',\n 'Polytrope_K_1.0_Gam_1.5.dat',\n 'apr_eos.table',\n 'delta_eos.table',\n 'eos_tov_20n0.dat',\n 'eos_tov_40n0.dat',\n 'sortedDD2YDelta.dat',\n 'sortedDSeos.dat',\n 'sorted_Sly4.dat',\n 'EOS_Quarkyonia_0.12_380.00.dat',\n 'EOS_Quarkyonia_0.20_380.00.dat',\n 'EOS_Quarkyonia_0.30_380.00.dat']</code>\n</pre>"},{"location":"tutorials/TOV_code/#tutorial-1-using-the-tov-code","title":"Tutorial 1: using the TOV code","text":""},{"location":"tutorials/TOV_code/#author-alexandra-c-semposki","title":"Author: Alexandra C. Semposki","text":"<p>Welcome to our tutorials! Here you can learn how to use our TOV solver for your own EOS codes, by using the classic SLy4 EOS as a test EOS. Below we start by importing the relevant functions and packages.</p>"},{"location":"tutorials/TOV_code/#using-tov-solver","title":"Using TOV solver","text":"<p>To use the TOV solver, one can use the EOSs provided in the EOS_Data folder or generate their own EOS. In this example we will use APR EOS.</p>"},{"location":"tutorials/TOV_code/#plot-tidal-deformability-k_2","title":"Plot tidal deformability: k_2","text":""},{"location":"tutorials/TOV_code/#tabular-equations-of-state","title":"Tabular Equations of state","text":"<p>We provide a list of tabular equations of state, some of which have been obtained from the CompOSE database. They can be listed as below:</p>"}]}